// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "PCRasterXSD.h"

namespace pcrxml
{
  // SpatialType
  // 

  SpatialType::
  SpatialType (value v)
  : ::xml_schema::string (_xsd_SpatialType_literals_[v])
  {
  }

  SpatialType::
  SpatialType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  SpatialType::
  SpatialType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  SpatialType::
  SpatialType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  SpatialType::
  SpatialType (const SpatialType& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  SpatialType& SpatialType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_SpatialType_literals_[v]);

    return *this;
  }


  // SpatialTypeOfValue
  // 

  SpatialTypeOfValue::
  SpatialTypeOfValue (value v)
  : ::pcrxml::SpatialType (v)
  {
  }

  SpatialTypeOfValue::
  SpatialTypeOfValue (const char* v)
  : ::pcrxml::SpatialType (v)
  {
  }

  SpatialTypeOfValue::
  SpatialTypeOfValue (const ::std::string& v)
  : ::pcrxml::SpatialType (v)
  {
  }

  SpatialTypeOfValue::
  SpatialTypeOfValue (const ::pcrxml::SpatialType& v)
  : ::pcrxml::SpatialType (v)
  {
  }

  SpatialTypeOfValue::
  SpatialTypeOfValue (const SpatialTypeOfValue& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::pcrxml::SpatialType (v, f, c)
  {
  }

  SpatialTypeOfValue& SpatialTypeOfValue::
  operator= (value v)
  {
    static_cast< ::pcrxml::SpatialType& > (*this) = v;

    return *this;
  }


  // MemoryExchange
  // 


  // Exchange
  // 

  const Exchange::external_optional& Exchange::
  external () const
  {
    return this->external_;
  }

  Exchange::external_optional& Exchange::
  external ()
  {
    return this->external_;
  }

  void Exchange::
  external (const external_type& x)
  {
    this->external_.set (x);
  }

  void Exchange::
  external (const external_optional& x)
  {
    this->external_ = x;
  }

  void Exchange::
  external (::std::unique_ptr< external_type > x)
  {
    this->external_.set (std::move (x));
  }

  const Exchange::memoryExchange_optional& Exchange::
  memoryExchange () const
  {
    return this->memoryExchange_;
  }

  Exchange::memoryExchange_optional& Exchange::
  memoryExchange ()
  {
    return this->memoryExchange_;
  }

  void Exchange::
  memoryExchange (const memoryExchange_type& x)
  {
    this->memoryExchange_.set (x);
  }

  void Exchange::
  memoryExchange (const memoryExchange_optional& x)
  {
    this->memoryExchange_ = x;
  }

  void Exchange::
  memoryExchange (::std::unique_ptr< memoryExchange_type > x)
  {
    this->memoryExchange_.set (std::move (x));
  }


  // Description
  // 

  const Description::text_type& Description::
  text () const
  {
    return this->text_.get ();
  }

  Description::text_type& Description::
  text ()
  {
    return this->text_.get ();
  }

  void Description::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void Description::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }


  // ModelInputType
  // 

  ModelInputType::
  ModelInputType (value v)
  : ::xml_schema::string (_xsd_ModelInputType_literals_[v])
  {
  }

  ModelInputType::
  ModelInputType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ModelInputType::
  ModelInputType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ModelInputType::
  ModelInputType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ModelInputType::
  ModelInputType (const ModelInputType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ModelInputType& ModelInputType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ModelInputType_literals_[v]);

    return *this;
  }


  // ModelOutputType
  // 

  ModelOutputType::
  ModelOutputType (value v)
  : ::xml_schema::string (_xsd_ModelOutputType_literals_[v])
  {
  }

  ModelOutputType::
  ModelOutputType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ModelOutputType::
  ModelOutputType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ModelOutputType::
  ModelOutputType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ModelOutputType::
  ModelOutputType (const ModelOutputType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ModelOutputType& ModelOutputType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ModelOutputType_literals_[v]);

    return *this;
  }


  // ModelExchange
  // 

  const ModelExchange::input_optional& ModelExchange::
  input () const
  {
    return this->input_;
  }

  ModelExchange::input_optional& ModelExchange::
  input ()
  {
    return this->input_;
  }

  void ModelExchange::
  input (const input_type& x)
  {
    this->input_.set (x);
  }

  void ModelExchange::
  input (const input_optional& x)
  {
    this->input_ = x;
  }

  void ModelExchange::
  input (::std::unique_ptr< input_type > x)
  {
    this->input_.set (std::move (x));
  }

  const ModelExchange::output_optional& ModelExchange::
  output () const
  {
    return this->output_;
  }

  ModelExchange::output_optional& ModelExchange::
  output ()
  {
    return this->output_;
  }

  void ModelExchange::
  output (const output_type& x)
  {
    this->output_.set (x);
  }

  void ModelExchange::
  output (const output_optional& x)
  {
    this->output_ = x;
  }

  void ModelExchange::
  output (::std::unique_ptr< output_type > x)
  {
    this->output_.set (std::move (x));
  }


  // LookupColumn
  // 


  // OutputMapFormat
  // 

  const OutputMapFormat::pcrasterMapFormat_optional& OutputMapFormat::
  pcrasterMapFormat () const
  {
    return this->pcrasterMapFormat_;
  }

  OutputMapFormat::pcrasterMapFormat_optional& OutputMapFormat::
  pcrasterMapFormat ()
  {
    return this->pcrasterMapFormat_;
  }

  void OutputMapFormat::
  pcrasterMapFormat (const pcrasterMapFormat_type& x)
  {
    this->pcrasterMapFormat_.set (x);
  }

  void OutputMapFormat::
  pcrasterMapFormat (const pcrasterMapFormat_optional& x)
  {
    this->pcrasterMapFormat_ = x;
  }

  void OutputMapFormat::
  pcrasterMapFormat (::std::unique_ptr< pcrasterMapFormat_type > x)
  {
    this->pcrasterMapFormat_.set (std::move (x));
  }

  const OutputMapFormat::bandMapFormat_optional& OutputMapFormat::
  bandMapFormat () const
  {
    return this->bandMapFormat_;
  }

  OutputMapFormat::bandMapFormat_optional& OutputMapFormat::
  bandMapFormat ()
  {
    return this->bandMapFormat_;
  }

  void OutputMapFormat::
  bandMapFormat (const bandMapFormat_type& x)
  {
    this->bandMapFormat_.set (x);
  }

  void OutputMapFormat::
  bandMapFormat (const bandMapFormat_optional& x)
  {
    this->bandMapFormat_ = x;
  }

  void OutputMapFormat::
  bandMapFormat (::std::unique_ptr< bandMapFormat_type > x)
  {
    this->bandMapFormat_.set (std::move (x));
  }

  const OutputMapFormat::esriGridFormat_optional& OutputMapFormat::
  esriGridFormat () const
  {
    return this->esriGridFormat_;
  }

  OutputMapFormat::esriGridFormat_optional& OutputMapFormat::
  esriGridFormat ()
  {
    return this->esriGridFormat_;
  }

  void OutputMapFormat::
  esriGridFormat (const esriGridFormat_type& x)
  {
    this->esriGridFormat_.set (x);
  }

  void OutputMapFormat::
  esriGridFormat (const esriGridFormat_optional& x)
  {
    this->esriGridFormat_ = x;
  }

  void OutputMapFormat::
  esriGridFormat (::std::unique_ptr< esriGridFormat_type > x)
  {
    this->esriGridFormat_.set (std::move (x));
  }


  // CellCoordinate
  // 

  CellCoordinate::
  CellCoordinate (value v)
  : ::xml_schema::string (_xsd_CellCoordinate_literals_[v])
  {
  }

  CellCoordinate::
  CellCoordinate (const char* v)
  : ::xml_schema::string (v)
  {
  }

  CellCoordinate::
  CellCoordinate (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  CellCoordinate::
  CellCoordinate (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  CellCoordinate::
  CellCoordinate (const CellCoordinate& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  CellCoordinate& CellCoordinate::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_CellCoordinate_literals_[v]);

    return *this;
  }


  // DirectionalValueUnit
  // 

  DirectionalValueUnit::
  DirectionalValueUnit (value v)
  : ::xml_schema::string (_xsd_DirectionalValueUnit_literals_[v])
  {
  }

  DirectionalValueUnit::
  DirectionalValueUnit (const char* v)
  : ::xml_schema::string (v)
  {
  }

  DirectionalValueUnit::
  DirectionalValueUnit (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  DirectionalValueUnit::
  DirectionalValueUnit (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  DirectionalValueUnit::
  DirectionalValueUnit (const DirectionalValueUnit& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  DirectionalValueUnit& DirectionalValueUnit::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_DirectionalValueUnit_literals_[v]);

    return *this;
  }


  // LddCreateDemMethod
  // 

  LddCreateDemMethod::
  LddCreateDemMethod (value v)
  : ::xml_schema::string (_xsd_LddCreateDemMethod_literals_[v])
  {
  }

  LddCreateDemMethod::
  LddCreateDemMethod (const char* v)
  : ::xml_schema::string (v)
  {
  }

  LddCreateDemMethod::
  LddCreateDemMethod (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  LddCreateDemMethod::
  LddCreateDemMethod (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  LddCreateDemMethod::
  LddCreateDemMethod (const LddCreateDemMethod& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  LddCreateDemMethod& LddCreateDemMethod::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_LddCreateDemMethod_literals_[v]);

    return *this;
  }


  // DynamicWaveRoughness
  // 

  DynamicWaveRoughness::
  DynamicWaveRoughness (value v)
  : ::xml_schema::string (_xsd_DynamicWaveRoughness_literals_[v])
  {
  }

  DynamicWaveRoughness::
  DynamicWaveRoughness (const char* v)
  : ::xml_schema::string (v)
  {
  }

  DynamicWaveRoughness::
  DynamicWaveRoughness (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  DynamicWaveRoughness::
  DynamicWaveRoughness (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  DynamicWaveRoughness::
  DynamicWaveRoughness (const DynamicWaveRoughness& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  DynamicWaveRoughness& DynamicWaveRoughness::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_DynamicWaveRoughness_literals_[v]);

    return *this;
  }


  // ExecutionOptions
  // 

  const ExecutionOptions::outputMapFormat_optional& ExecutionOptions::
  outputMapFormat () const
  {
    return this->outputMapFormat_;
  }

  ExecutionOptions::outputMapFormat_optional& ExecutionOptions::
  outputMapFormat ()
  {
    return this->outputMapFormat_;
  }

  void ExecutionOptions::
  outputMapFormat (const outputMapFormat_type& x)
  {
    this->outputMapFormat_.set (x);
  }

  void ExecutionOptions::
  outputMapFormat (const outputMapFormat_optional& x)
  {
    this->outputMapFormat_ = x;
  }

  void ExecutionOptions::
  outputMapFormat (::std::unique_ptr< outputMapFormat_type > x)
  {
    this->outputMapFormat_.set (std::move (x));
  }

  const ExecutionOptions::diagonal_optional& ExecutionOptions::
  diagonal () const
  {
    return this->diagonal_;
  }

  ExecutionOptions::diagonal_optional& ExecutionOptions::
  diagonal ()
  {
    return this->diagonal_;
  }

  void ExecutionOptions::
  diagonal (const diagonal_type& x)
  {
    this->diagonal_.set (x);
  }

  void ExecutionOptions::
  diagonal (const diagonal_optional& x)
  {
    this->diagonal_ = x;
  }

  const ExecutionOptions::twoColumnTableAsMatrix_optional& ExecutionOptions::
  twoColumnTableAsMatrix () const
  {
    return this->twoColumnTableAsMatrix_;
  }

  ExecutionOptions::twoColumnTableAsMatrix_optional& ExecutionOptions::
  twoColumnTableAsMatrix ()
  {
    return this->twoColumnTableAsMatrix_;
  }

  void ExecutionOptions::
  twoColumnTableAsMatrix (const twoColumnTableAsMatrix_type& x)
  {
    this->twoColumnTableAsMatrix_.set (x);
  }

  void ExecutionOptions::
  twoColumnTableAsMatrix (const twoColumnTableAsMatrix_optional& x)
  {
    this->twoColumnTableAsMatrix_ = x;
  }

  const ExecutionOptions::keepEdgePits_optional& ExecutionOptions::
  keepEdgePits () const
  {
    return this->keepEdgePits_;
  }

  ExecutionOptions::keepEdgePits_optional& ExecutionOptions::
  keepEdgePits ()
  {
    return this->keepEdgePits_;
  }

  void ExecutionOptions::
  keepEdgePits (const keepEdgePits_type& x)
  {
    this->keepEdgePits_.set (x);
  }

  void ExecutionOptions::
  keepEdgePits (const keepEdgePits_optional& x)
  {
    this->keepEdgePits_ = x;
  }

  const ExecutionOptions::trueCellUnits_optional& ExecutionOptions::
  trueCellUnits () const
  {
    return this->trueCellUnits_;
  }

  ExecutionOptions::trueCellUnits_optional& ExecutionOptions::
  trueCellUnits ()
  {
    return this->trueCellUnits_;
  }

  void ExecutionOptions::
  trueCellUnits (const trueCellUnits_type& x)
  {
    this->trueCellUnits_.set (x);
  }

  void ExecutionOptions::
  trueCellUnits (const trueCellUnits_optional& x)
  {
    this->trueCellUnits_ = x;
  }

  const ExecutionOptions::cellCoordinate_optional& ExecutionOptions::
  cellCoordinate () const
  {
    return this->cellCoordinate_;
  }

  ExecutionOptions::cellCoordinate_optional& ExecutionOptions::
  cellCoordinate ()
  {
    return this->cellCoordinate_;
  }

  void ExecutionOptions::
  cellCoordinate (const cellCoordinate_type& x)
  {
    this->cellCoordinate_.set (x);
  }

  void ExecutionOptions::
  cellCoordinate (const cellCoordinate_optional& x)
  {
    this->cellCoordinate_ = x;
  }

  void ExecutionOptions::
  cellCoordinate (::std::unique_ptr< cellCoordinate_type > x)
  {
    this->cellCoordinate_.set (std::move (x));
  }

  const ExecutionOptions::directionalValueUnit_optional& ExecutionOptions::
  directionalValueUnit () const
  {
    return this->directionalValueUnit_;
  }

  ExecutionOptions::directionalValueUnit_optional& ExecutionOptions::
  directionalValueUnit ()
  {
    return this->directionalValueUnit_;
  }

  void ExecutionOptions::
  directionalValueUnit (const directionalValueUnit_type& x)
  {
    this->directionalValueUnit_.set (x);
  }

  void ExecutionOptions::
  directionalValueUnit (const directionalValueUnit_optional& x)
  {
    this->directionalValueUnit_ = x;
  }

  void ExecutionOptions::
  directionalValueUnit (::std::unique_ptr< directionalValueUnit_type > x)
  {
    this->directionalValueUnit_.set (std::move (x));
  }

  const ExecutionOptions::lddCreateDemMethod_optional& ExecutionOptions::
  lddCreateDemMethod () const
  {
    return this->lddCreateDemMethod_;
  }

  ExecutionOptions::lddCreateDemMethod_optional& ExecutionOptions::
  lddCreateDemMethod ()
  {
    return this->lddCreateDemMethod_;
  }

  void ExecutionOptions::
  lddCreateDemMethod (const lddCreateDemMethod_type& x)
  {
    this->lddCreateDemMethod_.set (x);
  }

  void ExecutionOptions::
  lddCreateDemMethod (const lddCreateDemMethod_optional& x)
  {
    this->lddCreateDemMethod_ = x;
  }

  void ExecutionOptions::
  lddCreateDemMethod (::std::unique_ptr< lddCreateDemMethod_type > x)
  {
    this->lddCreateDemMethod_.set (std::move (x));
  }

  const ExecutionOptions::dynamicWaveRoughness_optional& ExecutionOptions::
  dynamicWaveRoughness () const
  {
    return this->dynamicWaveRoughness_;
  }

  ExecutionOptions::dynamicWaveRoughness_optional& ExecutionOptions::
  dynamicWaveRoughness ()
  {
    return this->dynamicWaveRoughness_;
  }

  void ExecutionOptions::
  dynamicWaveRoughness (const dynamicWaveRoughness_type& x)
  {
    this->dynamicWaveRoughness_.set (x);
  }

  void ExecutionOptions::
  dynamicWaveRoughness (const dynamicWaveRoughness_optional& x)
  {
    this->dynamicWaveRoughness_ = x;
  }

  void ExecutionOptions::
  dynamicWaveRoughness (::std::unique_ptr< dynamicWaveRoughness_type > x)
  {
    this->dynamicWaveRoughness_.set (std::move (x));
  }

  const ExecutionOptions::runDirectory_optional& ExecutionOptions::
  runDirectory () const
  {
    return this->runDirectory_;
  }

  ExecutionOptions::runDirectory_optional& ExecutionOptions::
  runDirectory ()
  {
    return this->runDirectory_;
  }

  void ExecutionOptions::
  runDirectory (const runDirectory_type& x)
  {
    this->runDirectory_.set (x);
  }

  void ExecutionOptions::
  runDirectory (const runDirectory_optional& x)
  {
    this->runDirectory_ = x;
  }

  void ExecutionOptions::
  runDirectory (::std::unique_ptr< runDirectory_type > x)
  {
    this->runDirectory_.set (std::move (x));
  }

  const ExecutionOptions::randomGeneratorSeed_optional& ExecutionOptions::
  randomGeneratorSeed () const
  {
    return this->randomGeneratorSeed_;
  }

  ExecutionOptions::randomGeneratorSeed_optional& ExecutionOptions::
  randomGeneratorSeed ()
  {
    return this->randomGeneratorSeed_;
  }

  void ExecutionOptions::
  randomGeneratorSeed (const randomGeneratorSeed_type& x)
  {
    this->randomGeneratorSeed_.set (x);
  }

  void ExecutionOptions::
  randomGeneratorSeed (const randomGeneratorSeed_optional& x)
  {
    this->randomGeneratorSeed_ = x;
  }

  void ExecutionOptions::
  randomGeneratorSeed (::std::unique_ptr< randomGeneratorSeed_type > x)
  {
    this->randomGeneratorSeed_.set (std::move (x));
  }

  const ExecutionOptions::maskCompression_optional& ExecutionOptions::
  maskCompression () const
  {
    return this->maskCompression_;
  }

  ExecutionOptions::maskCompression_optional& ExecutionOptions::
  maskCompression ()
  {
    return this->maskCompression_;
  }

  void ExecutionOptions::
  maskCompression (const maskCompression_type& x)
  {
    this->maskCompression_.set (x);
  }

  void ExecutionOptions::
  maskCompression (const maskCompression_optional& x)
  {
    this->maskCompression_ = x;
  }

  void ExecutionOptions::
  maskCompression (::std::unique_ptr< maskCompression_type > x)
  {
    this->maskCompression_.set (std::move (x));
  }

  const ExecutionOptions::useDiskStorage_optional& ExecutionOptions::
  useDiskStorage () const
  {
    return this->useDiskStorage_;
  }

  ExecutionOptions::useDiskStorage_optional& ExecutionOptions::
  useDiskStorage ()
  {
    return this->useDiskStorage_;
  }

  void ExecutionOptions::
  useDiskStorage (const useDiskStorage_type& x)
  {
    this->useDiskStorage_.set (x);
  }

  void ExecutionOptions::
  useDiskStorage (const useDiskStorage_optional& x)
  {
    this->useDiskStorage_ = x;
  }

  void ExecutionOptions::
  useDiskStorage (::std::unique_ptr< useDiskStorage_type > x)
  {
    this->useDiskStorage_.set (std::move (x));
  }


  // Script
  // 

  const Script::executionOptions_optional& Script::
  executionOptions () const
  {
    return this->executionOptions_;
  }

  Script::executionOptions_optional& Script::
  executionOptions ()
  {
    return this->executionOptions_;
  }

  void Script::
  executionOptions (const executionOptions_type& x)
  {
    this->executionOptions_.set (x);
  }

  void Script::
  executionOptions (const executionOptions_optional& x)
  {
    this->executionOptions_ = x;
  }

  void Script::
  executionOptions (::std::unique_ptr< executionOptions_type > x)
  {
    this->executionOptions_.set (std::move (x));
  }

  const Script::areaMap_optional& Script::
  areaMap () const
  {
    return this->areaMap_;
  }

  Script::areaMap_optional& Script::
  areaMap ()
  {
    return this->areaMap_;
  }

  void Script::
  areaMap (const areaMap_type& x)
  {
    this->areaMap_.set (x);
  }

  void Script::
  areaMap (const areaMap_optional& x)
  {
    this->areaMap_ = x;
  }

  void Script::
  areaMap (::std::unique_ptr< areaMap_type > x)
  {
    this->areaMap_.set (std::move (x));
  }

  const Script::computationMask_optional& Script::
  computationMask () const
  {
    return this->computationMask_;
  }

  Script::computationMask_optional& Script::
  computationMask ()
  {
    return this->computationMask_;
  }

  void Script::
  computationMask (const computationMask_type& x)
  {
    this->computationMask_.set (x);
  }

  void Script::
  computationMask (const computationMask_optional& x)
  {
    this->computationMask_ = x;
  }

  void Script::
  computationMask (::std::unique_ptr< computationMask_type > x)
  {
    this->computationMask_.set (std::move (x));
  }

  const Script::definition_sequence& Script::
  definition () const
  {
    return this->definition_;
  }

  Script::definition_sequence& Script::
  definition ()
  {
    return this->definition_;
  }

  void Script::
  definition (const definition_sequence& s)
  {
    this->definition_ = s;
  }

  const Script::timer_optional& Script::
  timer () const
  {
    return this->timer_;
  }

  Script::timer_optional& Script::
  timer ()
  {
    return this->timer_;
  }

  void Script::
  timer (const timer_type& x)
  {
    this->timer_.set (x);
  }

  void Script::
  timer (const timer_optional& x)
  {
    this->timer_ = x;
  }

  void Script::
  timer (::std::unique_ptr< timer_type > x)
  {
    this->timer_.set (std::move (x));
  }

  const Script::model_optional& Script::
  model () const
  {
    return this->model_;
  }

  Script::model_optional& Script::
  model ()
  {
    return this->model_;
  }

  void Script::
  model (const model_type& x)
  {
    this->model_.set (x);
  }

  void Script::
  model (const model_optional& x)
  {
    this->model_ = x;
  }

  void Script::
  model (::std::unique_ptr< model_type > x)
  {
    this->model_.set (std::move (x));
  }

  const Script::textStatistics_sequence& Script::
  textStatistics () const
  {
    return this->textStatistics_;
  }

  Script::textStatistics_sequence& Script::
  textStatistics ()
  {
    return this->textStatistics_;
  }

  void Script::
  textStatistics (const textStatistics_sequence& s)
  {
    this->textStatistics_ = s;
  }


  // Model
  // 

  const Model::textModel_type& Model::
  textModel () const
  {
    return this->textModel_.get ();
  }

  Model::textModel_type& Model::
  textModel ()
  {
    return this->textModel_.get ();
  }

  void Model::
  textModel (const textModel_type& x)
  {
    this->textModel_.set (x);
  }

  void Model::
  textModel (::std::unique_ptr< textModel_type > x)
  {
    this->textModel_.set (std::move (x));
  }


  // TextStatisticsSubject
  // 

  const TextStatisticsSubject::fieldRef_type& TextStatisticsSubject::
  fieldRef () const
  {
    return this->fieldRef_.get ();
  }

  TextStatisticsSubject::fieldRef_type& TextStatisticsSubject::
  fieldRef ()
  {
    return this->fieldRef_.get ();
  }

  void TextStatisticsSubject::
  fieldRef (const fieldRef_type& x)
  {
    this->fieldRef_.set (x);
  }

  void TextStatisticsSubject::
  fieldRef (::std::unique_ptr< fieldRef_type > x)
  {
    this->fieldRef_.set (std::move (x));
  }

  const TextStatisticsSubject::intervalRef_optional& TextStatisticsSubject::
  intervalRef () const
  {
    return this->intervalRef_;
  }

  TextStatisticsSubject::intervalRef_optional& TextStatisticsSubject::
  intervalRef ()
  {
    return this->intervalRef_;
  }

  void TextStatisticsSubject::
  intervalRef (const intervalRef_type& x)
  {
    this->intervalRef_.set (x);
  }

  void TextStatisticsSubject::
  intervalRef (const intervalRef_optional& x)
  {
    this->intervalRef_ = x;
  }

  void TextStatisticsSubject::
  intervalRef (::std::unique_ptr< intervalRef_type > x)
  {
    this->intervalRef_.set (std::move (x));
  }


  // TextStatistics
  // 

  const TextStatistics::textStatisticsSubject_sequence& TextStatistics::
  textStatisticsSubject () const
  {
    return this->textStatisticsSubject_;
  }

  TextStatistics::textStatisticsSubject_sequence& TextStatistics::
  textStatisticsSubject ()
  {
    return this->textStatisticsSubject_;
  }

  void TextStatistics::
  textStatisticsSubject (const textStatisticsSubject_sequence& s)
  {
    this->textStatisticsSubject_ = s;
  }

  const TextStatistics::name_optional& TextStatistics::
  name () const
  {
    return this->name_;
  }

  TextStatistics::name_optional& TextStatistics::
  name ()
  {
    return this->name_;
  }

  void TextStatistics::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void TextStatistics::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void TextStatistics::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // LookupRow
  // 

  const LookupRow::lookupColumn_sequence& LookupRow::
  lookupColumn () const
  {
    return this->lookupColumn_;
  }

  LookupRow::lookupColumn_sequence& LookupRow::
  lookupColumn ()
  {
    return this->lookupColumn_;
  }

  void LookupRow::
  lookupColumn (const lookupColumn_sequence& s)
  {
    this->lookupColumn_ = s;
  }


  // Relation
  // 

  const Relation::lookupTable_optional& Relation::
  lookupTable () const
  {
    return this->lookupTable_;
  }

  Relation::lookupTable_optional& Relation::
  lookupTable ()
  {
    return this->lookupTable_;
  }

  void Relation::
  lookupTable (const lookupTable_type& x)
  {
    this->lookupTable_.set (x);
  }

  void Relation::
  lookupTable (const lookupTable_optional& x)
  {
    this->lookupTable_ = x;
  }

  void Relation::
  lookupTable (::std::unique_ptr< lookupTable_type > x)
  {
    this->lookupTable_.set (std::move (x));
  }

  const Relation::indexedArray_optional& Relation::
  indexedArray () const
  {
    return this->indexedArray_;
  }

  Relation::indexedArray_optional& Relation::
  indexedArray ()
  {
    return this->indexedArray_;
  }

  void Relation::
  indexedArray (const indexedArray_type& x)
  {
    this->indexedArray_.set (x);
  }

  void Relation::
  indexedArray (const indexedArray_optional& x)
  {
    this->indexedArray_ = x;
  }

  void Relation::
  indexedArray (::std::unique_ptr< indexedArray_type > x)
  {
    this->indexedArray_.set (std::move (x));
  }


  // ArrayDimensionDataType
  // 

  ArrayDimensionDataType::
  ArrayDimensionDataType (value v)
  : ::xml_schema::string (_xsd_ArrayDimensionDataType_literals_[v])
  {
  }

  ArrayDimensionDataType::
  ArrayDimensionDataType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ArrayDimensionDataType::
  ArrayDimensionDataType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ArrayDimensionDataType::
  ArrayDimensionDataType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ArrayDimensionDataType::
  ArrayDimensionDataType (const ArrayDimensionDataType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ArrayDimensionDataType& ArrayDimensionDataType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ArrayDimensionDataType_literals_[v]);

    return *this;
  }


  // ArrayValueDataType
  // 

  ArrayValueDataType::
  ArrayValueDataType (value v)
  : ::xml_schema::string (_xsd_ArrayValueDataType_literals_[v])
  {
  }

  ArrayValueDataType::
  ArrayValueDataType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ArrayValueDataType::
  ArrayValueDataType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ArrayValueDataType::
  ArrayValueDataType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ArrayValueDataType::
  ArrayValueDataType (const ArrayValueDataType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ArrayValueDataType& ArrayValueDataType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ArrayValueDataType_literals_[v]);

    return *this;
  }


  // IndexedArray
  // 

  const IndexedArray::dimensionDataType_type& IndexedArray::
  dimensionDataType () const
  {
    return this->dimensionDataType_.get ();
  }

  IndexedArray::dimensionDataType_type& IndexedArray::
  dimensionDataType ()
  {
    return this->dimensionDataType_.get ();
  }

  void IndexedArray::
  dimensionDataType (const dimensionDataType_type& x)
  {
    this->dimensionDataType_.set (x);
  }

  void IndexedArray::
  dimensionDataType (::std::unique_ptr< dimensionDataType_type > x)
  {
    this->dimensionDataType_.set (std::move (x));
  }

  const IndexedArray::valueDataType_type& IndexedArray::
  valueDataType () const
  {
    return this->valueDataType_.get ();
  }

  IndexedArray::valueDataType_type& IndexedArray::
  valueDataType ()
  {
    return this->valueDataType_.get ();
  }

  void IndexedArray::
  valueDataType (const valueDataType_type& x)
  {
    this->valueDataType_.set (x);
  }

  void IndexedArray::
  valueDataType (::std::unique_ptr< valueDataType_type > x)
  {
    this->valueDataType_.set (std::move (x));
  }


  // LookupTable
  // 

  const LookupTable::lookupRow_sequence& LookupTable::
  lookupRow () const
  {
    return this->lookupRow_;
  }

  LookupTable::lookupRow_sequence& LookupTable::
  lookupRow ()
  {
    return this->lookupRow_;
  }

  void LookupTable::
  lookupRow (const lookupRow_sequence& s)
  {
    this->lookupRow_ = s;
  }


  // FieldValueOrType
  // 

  const FieldValueOrType::dataType_optional& FieldValueOrType::
  dataType () const
  {
    return this->dataType_;
  }

  FieldValueOrType::dataType_optional& FieldValueOrType::
  dataType ()
  {
    return this->dataType_;
  }

  void FieldValueOrType::
  dataType (const dataType_type& x)
  {
    this->dataType_.set (x);
  }

  void FieldValueOrType::
  dataType (const dataType_optional& x)
  {
    this->dataType_ = x;
  }

  void FieldValueOrType::
  dataType (::std::unique_ptr< dataType_type > x)
  {
    this->dataType_.set (std::move (x));
  }

  const FieldValueOrType::number_optional& FieldValueOrType::
  number () const
  {
    return this->number_;
  }

  FieldValueOrType::number_optional& FieldValueOrType::
  number ()
  {
    return this->number_;
  }

  void FieldValueOrType::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void FieldValueOrType::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  const FieldValueOrType::spatialType_optional& FieldValueOrType::
  spatialType () const
  {
    return this->spatialType_;
  }

  FieldValueOrType::spatialType_optional& FieldValueOrType::
  spatialType ()
  {
    return this->spatialType_;
  }

  void FieldValueOrType::
  spatialType (const spatialType_type& x)
  {
    this->spatialType_.set (x);
  }

  void FieldValueOrType::
  spatialType (const spatialType_optional& x)
  {
    this->spatialType_ = x;
  }

  void FieldValueOrType::
  spatialType (::std::unique_ptr< spatialType_type > x)
  {
    this->spatialType_.set (std::move (x));
  }


  // Definition
  // 

  const Definition::description_optional& Definition::
  description () const
  {
    return this->description_;
  }

  Definition::description_optional& Definition::
  description ()
  {
    return this->description_;
  }

  void Definition::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Definition::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void Definition::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const Definition::field_optional& Definition::
  field () const
  {
    return this->field_;
  }

  Definition::field_optional& Definition::
  field ()
  {
    return this->field_;
  }

  void Definition::
  field (const field_type& x)
  {
    this->field_.set (x);
  }

  void Definition::
  field (const field_optional& x)
  {
    this->field_ = x;
  }

  void Definition::
  field (::std::unique_ptr< field_type > x)
  {
    this->field_.set (std::move (x));
  }

  const Definition::relation_optional& Definition::
  relation () const
  {
    return this->relation_;
  }

  Definition::relation_optional& Definition::
  relation ()
  {
    return this->relation_;
  }

  void Definition::
  relation (const relation_type& x)
  {
    this->relation_.set (x);
  }

  void Definition::
  relation (const relation_optional& x)
  {
    this->relation_ = x;
  }

  void Definition::
  relation (::std::unique_ptr< relation_type > x)
  {
    this->relation_.set (std::move (x));
  }

  const Definition::modelExchange_optional& Definition::
  modelExchange () const
  {
    return this->modelExchange_;
  }

  Definition::modelExchange_optional& Definition::
  modelExchange ()
  {
    return this->modelExchange_;
  }

  void Definition::
  modelExchange (const modelExchange_type& x)
  {
    this->modelExchange_.set (x);
  }

  void Definition::
  modelExchange (const modelExchange_optional& x)
  {
    this->modelExchange_ = x;
  }

  void Definition::
  modelExchange (::std::unique_ptr< modelExchange_type > x)
  {
    this->modelExchange_.set (std::move (x));
  }

  const Definition::scriptInput_optional& Definition::
  scriptInput () const
  {
    return this->scriptInput_;
  }

  Definition::scriptInput_optional& Definition::
  scriptInput ()
  {
    return this->scriptInput_;
  }

  void Definition::
  scriptInput (const scriptInput_type& x)
  {
    this->scriptInput_.set (x);
  }

  void Definition::
  scriptInput (const scriptInput_optional& x)
  {
    this->scriptInput_ = x;
  }

  void Definition::
  scriptInput (::std::unique_ptr< scriptInput_type > x)
  {
    this->scriptInput_.set (std::move (x));
  }

  const Definition::scriptOutput_optional& Definition::
  scriptOutput () const
  {
    return this->scriptOutput_;
  }

  Definition::scriptOutput_optional& Definition::
  scriptOutput ()
  {
    return this->scriptOutput_;
  }

  void Definition::
  scriptOutput (const scriptOutput_type& x)
  {
    this->scriptOutput_.set (x);
  }

  void Definition::
  scriptOutput (const scriptOutput_optional& x)
  {
    this->scriptOutput_ = x;
  }

  void Definition::
  scriptOutput (::std::unique_ptr< scriptOutput_type > x)
  {
    this->scriptOutput_.set (std::move (x));
  }

  const Definition::name_type& Definition::
  name () const
  {
    return this->name_.get ();
  }

  Definition::name_type& Definition::
  name ()
  {
    return this->name_.get ();
  }

  void Definition::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Definition::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // Boolean
  // 


  // Nominal
  // 


  // Ordinal
  // 


  // Directional
  // 


  // Ldd
  // 


  // Scalar
  // 

  const Scalar::length_optional& Scalar::
  length () const
  {
    return this->length_;
  }

  Scalar::length_optional& Scalar::
  length ()
  {
    return this->length_;
  }

  void Scalar::
  length (const length_type& x)
  {
    this->length_.set (x);
  }

  void Scalar::
  length (const length_optional& x)
  {
    this->length_ = x;
  }

  const Scalar::mass_optional& Scalar::
  mass () const
  {
    return this->mass_;
  }

  Scalar::mass_optional& Scalar::
  mass ()
  {
    return this->mass_;
  }

  void Scalar::
  mass (const mass_type& x)
  {
    this->mass_.set (x);
  }

  void Scalar::
  mass (const mass_optional& x)
  {
    this->mass_ = x;
  }

  const Scalar::time_optional& Scalar::
  time () const
  {
    return this->time_;
  }

  Scalar::time_optional& Scalar::
  time ()
  {
    return this->time_;
  }

  void Scalar::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void Scalar::
  time (const time_optional& x)
  {
    this->time_ = x;
  }

  const Scalar::electricCurrent_optional& Scalar::
  electricCurrent () const
  {
    return this->electricCurrent_;
  }

  Scalar::electricCurrent_optional& Scalar::
  electricCurrent ()
  {
    return this->electricCurrent_;
  }

  void Scalar::
  electricCurrent (const electricCurrent_type& x)
  {
    this->electricCurrent_.set (x);
  }

  void Scalar::
  electricCurrent (const electricCurrent_optional& x)
  {
    this->electricCurrent_ = x;
  }

  const Scalar::temperature_optional& Scalar::
  temperature () const
  {
    return this->temperature_;
  }

  Scalar::temperature_optional& Scalar::
  temperature ()
  {
    return this->temperature_;
  }

  void Scalar::
  temperature (const temperature_type& x)
  {
    this->temperature_.set (x);
  }

  void Scalar::
  temperature (const temperature_optional& x)
  {
    this->temperature_ = x;
  }

  const Scalar::amountOfSubstance_optional& Scalar::
  amountOfSubstance () const
  {
    return this->amountOfSubstance_;
  }

  Scalar::amountOfSubstance_optional& Scalar::
  amountOfSubstance ()
  {
    return this->amountOfSubstance_;
  }

  void Scalar::
  amountOfSubstance (const amountOfSubstance_type& x)
  {
    this->amountOfSubstance_.set (x);
  }

  void Scalar::
  amountOfSubstance (const amountOfSubstance_optional& x)
  {
    this->amountOfSubstance_ = x;
  }

  const Scalar::luminousIntensity_optional& Scalar::
  luminousIntensity () const
  {
    return this->luminousIntensity_;
  }

  Scalar::luminousIntensity_optional& Scalar::
  luminousIntensity ()
  {
    return this->luminousIntensity_;
  }

  void Scalar::
  luminousIntensity (const luminousIntensity_type& x)
  {
    this->luminousIntensity_.set (x);
  }

  void Scalar::
  luminousIntensity (const luminousIntensity_optional& x)
  {
    this->luminousIntensity_ = x;
  }

  const Scalar::currency_optional& Scalar::
  currency () const
  {
    return this->currency_;
  }

  Scalar::currency_optional& Scalar::
  currency ()
  {
    return this->currency_;
  }

  void Scalar::
  currency (const currency_type& x)
  {
    this->currency_.set (x);
  }

  void Scalar::
  currency (const currency_optional& x)
  {
    this->currency_ = x;
  }


  // DataType
  // 

  const DataType::boolean_optional& DataType::
  boolean () const
  {
    return this->boolean_;
  }

  DataType::boolean_optional& DataType::
  boolean ()
  {
    return this->boolean_;
  }

  void DataType::
  boolean (const boolean_type& x)
  {
    this->boolean_.set (x);
  }

  void DataType::
  boolean (const boolean_optional& x)
  {
    this->boolean_ = x;
  }

  void DataType::
  boolean (::std::unique_ptr< boolean_type > x)
  {
    this->boolean_.set (std::move (x));
  }

  const DataType::nominal_optional& DataType::
  nominal () const
  {
    return this->nominal_;
  }

  DataType::nominal_optional& DataType::
  nominal ()
  {
    return this->nominal_;
  }

  void DataType::
  nominal (const nominal_type& x)
  {
    this->nominal_.set (x);
  }

  void DataType::
  nominal (const nominal_optional& x)
  {
    this->nominal_ = x;
  }

  void DataType::
  nominal (::std::unique_ptr< nominal_type > x)
  {
    this->nominal_.set (std::move (x));
  }

  const DataType::ordinal_optional& DataType::
  ordinal () const
  {
    return this->ordinal_;
  }

  DataType::ordinal_optional& DataType::
  ordinal ()
  {
    return this->ordinal_;
  }

  void DataType::
  ordinal (const ordinal_type& x)
  {
    this->ordinal_.set (x);
  }

  void DataType::
  ordinal (const ordinal_optional& x)
  {
    this->ordinal_ = x;
  }

  void DataType::
  ordinal (::std::unique_ptr< ordinal_type > x)
  {
    this->ordinal_.set (std::move (x));
  }

  const DataType::scalar_optional& DataType::
  scalar () const
  {
    return this->scalar_;
  }

  DataType::scalar_optional& DataType::
  scalar ()
  {
    return this->scalar_;
  }

  void DataType::
  scalar (const scalar_type& x)
  {
    this->scalar_.set (x);
  }

  void DataType::
  scalar (const scalar_optional& x)
  {
    this->scalar_ = x;
  }

  void DataType::
  scalar (::std::unique_ptr< scalar_type > x)
  {
    this->scalar_.set (std::move (x));
  }

  const DataType::directional_optional& DataType::
  directional () const
  {
    return this->directional_;
  }

  DataType::directional_optional& DataType::
  directional ()
  {
    return this->directional_;
  }

  void DataType::
  directional (const directional_type& x)
  {
    this->directional_.set (x);
  }

  void DataType::
  directional (const directional_optional& x)
  {
    this->directional_ = x;
  }

  void DataType::
  directional (::std::unique_ptr< directional_type > x)
  {
    this->directional_.set (std::move (x));
  }

  const DataType::ldd_optional& DataType::
  ldd () const
  {
    return this->ldd_;
  }

  DataType::ldd_optional& DataType::
  ldd ()
  {
    return this->ldd_;
  }

  void DataType::
  ldd (const ldd_type& x)
  {
    this->ldd_.set (x);
  }

  void DataType::
  ldd (const ldd_optional& x)
  {
    this->ldd_ = x;
  }

  void DataType::
  ldd (::std::unique_ptr< ldd_type > x)
  {
    this->ldd_.set (std::move (x));
  }


  // DataTypeOfValue
  // 

  const DataTypeOfValue::boolean_optional& DataTypeOfValue::
  boolean () const
  {
    return this->boolean_;
  }

  DataTypeOfValue::boolean_optional& DataTypeOfValue::
  boolean ()
  {
    return this->boolean_;
  }

  void DataTypeOfValue::
  boolean (const boolean_type& x)
  {
    this->boolean_.set (x);
  }

  void DataTypeOfValue::
  boolean (const boolean_optional& x)
  {
    this->boolean_ = x;
  }

  void DataTypeOfValue::
  boolean (::std::unique_ptr< boolean_type > x)
  {
    this->boolean_.set (std::move (x));
  }

  const DataTypeOfValue::ldd_optional& DataTypeOfValue::
  ldd () const
  {
    return this->ldd_;
  }

  DataTypeOfValue::ldd_optional& DataTypeOfValue::
  ldd ()
  {
    return this->ldd_;
  }

  void DataTypeOfValue::
  ldd (const ldd_type& x)
  {
    this->ldd_.set (x);
  }

  void DataTypeOfValue::
  ldd (const ldd_optional& x)
  {
    this->ldd_ = x;
  }

  void DataTypeOfValue::
  ldd (::std::unique_ptr< ldd_type > x)
  {
    this->ldd_.set (std::move (x));
  }

  const DataTypeOfValue::nominal_optional& DataTypeOfValue::
  nominal () const
  {
    return this->nominal_;
  }

  DataTypeOfValue::nominal_optional& DataTypeOfValue::
  nominal ()
  {
    return this->nominal_;
  }

  void DataTypeOfValue::
  nominal (const nominal_type& x)
  {
    this->nominal_.set (x);
  }

  void DataTypeOfValue::
  nominal (const nominal_optional& x)
  {
    this->nominal_ = x;
  }

  void DataTypeOfValue::
  nominal (::std::unique_ptr< nominal_type > x)
  {
    this->nominal_.set (std::move (x));
  }

  const DataTypeOfValue::ordinal_optional& DataTypeOfValue::
  ordinal () const
  {
    return this->ordinal_;
  }

  DataTypeOfValue::ordinal_optional& DataTypeOfValue::
  ordinal ()
  {
    return this->ordinal_;
  }

  void DataTypeOfValue::
  ordinal (const ordinal_type& x)
  {
    this->ordinal_.set (x);
  }

  void DataTypeOfValue::
  ordinal (const ordinal_optional& x)
  {
    this->ordinal_ = x;
  }

  void DataTypeOfValue::
  ordinal (::std::unique_ptr< ordinal_type > x)
  {
    this->ordinal_.set (std::move (x));
  }

  const DataTypeOfValue::scalar_optional& DataTypeOfValue::
  scalar () const
  {
    return this->scalar_;
  }

  DataTypeOfValue::scalar_optional& DataTypeOfValue::
  scalar ()
  {
    return this->scalar_;
  }

  void DataTypeOfValue::
  scalar (const scalar_type& x)
  {
    this->scalar_.set (x);
  }

  void DataTypeOfValue::
  scalar (const scalar_optional& x)
  {
    this->scalar_ = x;
  }

  void DataTypeOfValue::
  scalar (::std::unique_ptr< scalar_type > x)
  {
    this->scalar_.set (std::move (x));
  }

  const DataTypeOfValue::directional_optional& DataTypeOfValue::
  directional () const
  {
    return this->directional_;
  }

  DataTypeOfValue::directional_optional& DataTypeOfValue::
  directional ()
  {
    return this->directional_;
  }

  void DataTypeOfValue::
  directional (const directional_type& x)
  {
    this->directional_.set (x);
  }

  void DataTypeOfValue::
  directional (const directional_optional& x)
  {
    this->directional_ = x;
  }

  void DataTypeOfValue::
  directional (::std::unique_ptr< directional_type > x)
  {
    this->directional_.set (std::move (x));
  }


  // CoordinateMask
  // 

  const CoordinateMask::xMinimum_type& CoordinateMask::
  xMinimum () const
  {
    return this->xMinimum_.get ();
  }

  CoordinateMask::xMinimum_type& CoordinateMask::
  xMinimum ()
  {
    return this->xMinimum_.get ();
  }

  void CoordinateMask::
  xMinimum (const xMinimum_type& x)
  {
    this->xMinimum_.set (x);
  }

  const CoordinateMask::xMaximum_type& CoordinateMask::
  xMaximum () const
  {
    return this->xMaximum_.get ();
  }

  CoordinateMask::xMaximum_type& CoordinateMask::
  xMaximum ()
  {
    return this->xMaximum_.get ();
  }

  void CoordinateMask::
  xMaximum (const xMaximum_type& x)
  {
    this->xMaximum_.set (x);
  }

  const CoordinateMask::yMinimum_type& CoordinateMask::
  yMinimum () const
  {
    return this->yMinimum_.get ();
  }

  CoordinateMask::yMinimum_type& CoordinateMask::
  yMinimum ()
  {
    return this->yMinimum_.get ();
  }

  void CoordinateMask::
  yMinimum (const yMinimum_type& x)
  {
    this->yMinimum_.set (x);
  }

  const CoordinateMask::yMaximum_type& CoordinateMask::
  yMaximum () const
  {
    return this->yMaximum_.get ();
  }

  CoordinateMask::yMaximum_type& CoordinateMask::
  yMaximum ()
  {
    return this->yMaximum_.get ();
  }

  void CoordinateMask::
  yMaximum (const yMaximum_type& x)
  {
    this->yMaximum_.set (x);
  }


  // AreaMap
  // 

  const AreaMap::nrRows_type& AreaMap::
  nrRows () const
  {
    return this->nrRows_.get ();
  }

  AreaMap::nrRows_type& AreaMap::
  nrRows ()
  {
    return this->nrRows_.get ();
  }

  void AreaMap::
  nrRows (const nrRows_type& x)
  {
    this->nrRows_.set (x);
  }

  void AreaMap::
  nrRows (::std::unique_ptr< nrRows_type > x)
  {
    this->nrRows_.set (std::move (x));
  }

  const AreaMap::nrCols_type& AreaMap::
  nrCols () const
  {
    return this->nrCols_.get ();
  }

  AreaMap::nrCols_type& AreaMap::
  nrCols ()
  {
    return this->nrCols_.get ();
  }

  void AreaMap::
  nrCols (const nrCols_type& x)
  {
    this->nrCols_.set (x);
  }

  void AreaMap::
  nrCols (::std::unique_ptr< nrCols_type > x)
  {
    this->nrCols_.set (std::move (x));
  }

  const AreaMap::cellSize_optional& AreaMap::
  cellSize () const
  {
    return this->cellSize_;
  }

  AreaMap::cellSize_optional& AreaMap::
  cellSize ()
  {
    return this->cellSize_;
  }

  void AreaMap::
  cellSize (const cellSize_type& x)
  {
    this->cellSize_.set (x);
  }

  void AreaMap::
  cellSize (const cellSize_optional& x)
  {
    this->cellSize_ = x;
  }

  AreaMap::cellSize_type AreaMap::
  cellSize_default_value ()
  {
    return cellSize_type (1.0);
  }

  const AreaMap::xLowerLeftCorner_optional& AreaMap::
  xLowerLeftCorner () const
  {
    return this->xLowerLeftCorner_;
  }

  AreaMap::xLowerLeftCorner_optional& AreaMap::
  xLowerLeftCorner ()
  {
    return this->xLowerLeftCorner_;
  }

  void AreaMap::
  xLowerLeftCorner (const xLowerLeftCorner_type& x)
  {
    this->xLowerLeftCorner_.set (x);
  }

  void AreaMap::
  xLowerLeftCorner (const xLowerLeftCorner_optional& x)
  {
    this->xLowerLeftCorner_ = x;
  }

  AreaMap::xLowerLeftCorner_type AreaMap::
  xLowerLeftCorner_default_value ()
  {
    return xLowerLeftCorner_type (.0);
  }

  const AreaMap::yLowerLeftCorner_optional& AreaMap::
  yLowerLeftCorner () const
  {
    return this->yLowerLeftCorner_;
  }

  AreaMap::yLowerLeftCorner_optional& AreaMap::
  yLowerLeftCorner ()
  {
    return this->yLowerLeftCorner_;
  }

  void AreaMap::
  yLowerLeftCorner (const yLowerLeftCorner_type& x)
  {
    this->yLowerLeftCorner_.set (x);
  }

  void AreaMap::
  yLowerLeftCorner (const yLowerLeftCorner_optional& x)
  {
    this->yLowerLeftCorner_ = x;
  }

  AreaMap::yLowerLeftCorner_type AreaMap::
  yLowerLeftCorner_default_value ()
  {
    return yLowerLeftCorner_type (.0);
  }


  // FieldReference
  // 

  const FieldReference::ref_type& FieldReference::
  ref () const
  {
    return this->ref_.get ();
  }

  FieldReference::ref_type& FieldReference::
  ref ()
  {
    return this->ref_.get ();
  }

  void FieldReference::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void FieldReference::
  ref (::std::unique_ptr< ref_type > x)
  {
    this->ref_.set (std::move (x));
  }


  // AreaMapScript
  // 

  const AreaMapScript::fieldReference_optional& AreaMapScript::
  fieldReference () const
  {
    return this->fieldReference_;
  }

  AreaMapScript::fieldReference_optional& AreaMapScript::
  fieldReference ()
  {
    return this->fieldReference_;
  }

  void AreaMapScript::
  fieldReference (const fieldReference_type& x)
  {
    this->fieldReference_.set (x);
  }

  void AreaMapScript::
  fieldReference (const fieldReference_optional& x)
  {
    this->fieldReference_ = x;
  }

  void AreaMapScript::
  fieldReference (::std::unique_ptr< fieldReference_type > x)
  {
    this->fieldReference_.set (std::move (x));
  }

  const AreaMapScript::nrRows_optional& AreaMapScript::
  nrRows () const
  {
    return this->nrRows_;
  }

  AreaMapScript::nrRows_optional& AreaMapScript::
  nrRows ()
  {
    return this->nrRows_;
  }

  void AreaMapScript::
  nrRows (const nrRows_type& x)
  {
    this->nrRows_.set (x);
  }

  void AreaMapScript::
  nrRows (const nrRows_optional& x)
  {
    this->nrRows_ = x;
  }

  void AreaMapScript::
  nrRows (::std::unique_ptr< nrRows_type > x)
  {
    this->nrRows_.set (std::move (x));
  }

  const AreaMapScript::nrCols_optional& AreaMapScript::
  nrCols () const
  {
    return this->nrCols_;
  }

  AreaMapScript::nrCols_optional& AreaMapScript::
  nrCols ()
  {
    return this->nrCols_;
  }

  void AreaMapScript::
  nrCols (const nrCols_type& x)
  {
    this->nrCols_.set (x);
  }

  void AreaMapScript::
  nrCols (const nrCols_optional& x)
  {
    this->nrCols_ = x;
  }

  void AreaMapScript::
  nrCols (::std::unique_ptr< nrCols_type > x)
  {
    this->nrCols_.set (std::move (x));
  }

  const AreaMapScript::cellSize_optional& AreaMapScript::
  cellSize () const
  {
    return this->cellSize_;
  }

  AreaMapScript::cellSize_optional& AreaMapScript::
  cellSize ()
  {
    return this->cellSize_;
  }

  void AreaMapScript::
  cellSize (const cellSize_type& x)
  {
    this->cellSize_.set (x);
  }

  void AreaMapScript::
  cellSize (const cellSize_optional& x)
  {
    this->cellSize_ = x;
  }

  AreaMapScript::cellSize_type AreaMapScript::
  cellSize_default_value ()
  {
    return cellSize_type (1.0);
  }

  const AreaMapScript::xLowerLeftCorner_optional& AreaMapScript::
  xLowerLeftCorner () const
  {
    return this->xLowerLeftCorner_;
  }

  AreaMapScript::xLowerLeftCorner_optional& AreaMapScript::
  xLowerLeftCorner ()
  {
    return this->xLowerLeftCorner_;
  }

  void AreaMapScript::
  xLowerLeftCorner (const xLowerLeftCorner_type& x)
  {
    this->xLowerLeftCorner_.set (x);
  }

  void AreaMapScript::
  xLowerLeftCorner (const xLowerLeftCorner_optional& x)
  {
    this->xLowerLeftCorner_ = x;
  }

  AreaMapScript::xLowerLeftCorner_type AreaMapScript::
  xLowerLeftCorner_default_value ()
  {
    return xLowerLeftCorner_type (.0);
  }

  const AreaMapScript::yLowerLeftCorner_optional& AreaMapScript::
  yLowerLeftCorner () const
  {
    return this->yLowerLeftCorner_;
  }

  AreaMapScript::yLowerLeftCorner_optional& AreaMapScript::
  yLowerLeftCorner ()
  {
    return this->yLowerLeftCorner_;
  }

  void AreaMapScript::
  yLowerLeftCorner (const yLowerLeftCorner_type& x)
  {
    this->yLowerLeftCorner_.set (x);
  }

  void AreaMapScript::
  yLowerLeftCorner (const yLowerLeftCorner_optional& x)
  {
    this->yLowerLeftCorner_ = x;
  }

  AreaMapScript::yLowerLeftCorner_type AreaMapScript::
  yLowerLeftCorner_default_value ()
  {
    return yLowerLeftCorner_type (.0);
  }


  // MaskMapType
  // 

  MaskMapType::
  MaskMapType (value v)
  : ::xml_schema::string (_xsd_MaskMapType_literals_[v])
  {
  }

  MaskMapType::
  MaskMapType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  MaskMapType::
  MaskMapType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  MaskMapType::
  MaskMapType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  MaskMapType::
  MaskMapType (const MaskMapType& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  MaskMapType& MaskMapType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_MaskMapType_literals_[v]);

    return *this;
  }


  // ComputationMaskByAreaMap
  // 

  const ComputationMaskByAreaMap::maskType_type& ComputationMaskByAreaMap::
  maskType () const
  {
    return this->maskType_.get ();
  }

  ComputationMaskByAreaMap::maskType_type& ComputationMaskByAreaMap::
  maskType ()
  {
    return this->maskType_.get ();
  }

  void ComputationMaskByAreaMap::
  maskType (const maskType_type& x)
  {
    this->maskType_.set (x);
  }

  void ComputationMaskByAreaMap::
  maskType (::std::unique_ptr< maskType_type > x)
  {
    this->maskType_.set (std::move (x));
  }


  // ComputationMask
  // 

  const ComputationMask::areaMap_optional& ComputationMask::
  areaMap () const
  {
    return this->areaMap_;
  }

  ComputationMask::areaMap_optional& ComputationMask::
  areaMap ()
  {
    return this->areaMap_;
  }

  void ComputationMask::
  areaMap (const areaMap_type& x)
  {
    this->areaMap_.set (x);
  }

  void ComputationMask::
  areaMap (const areaMap_optional& x)
  {
    this->areaMap_ = x;
  }

  void ComputationMask::
  areaMap (::std::unique_ptr< areaMap_type > x)
  {
    this->areaMap_.set (std::move (x));
  }

  const ComputationMask::coordinates_optional& ComputationMask::
  coordinates () const
  {
    return this->coordinates_;
  }

  ComputationMask::coordinates_optional& ComputationMask::
  coordinates ()
  {
    return this->coordinates_;
  }

  void ComputationMask::
  coordinates (const coordinates_type& x)
  {
    this->coordinates_.set (x);
  }

  void ComputationMask::
  coordinates (const coordinates_optional& x)
  {
    this->coordinates_ = x;
  }

  void ComputationMask::
  coordinates (::std::unique_ptr< coordinates_type > x)
  {
    this->coordinates_.set (std::move (x));
  }


  // TimerOfModel
  // 

  const TimerOfModel::integer_type& TimerOfModel::
  integer () const
  {
    return this->integer_.get ();
  }

  TimerOfModel::integer_type& TimerOfModel::
  integer ()
  {
    return this->integer_.get ();
  }

  void TimerOfModel::
  integer (const integer_type& x)
  {
    this->integer_.set (x);
  }

  void TimerOfModel::
  integer (::std::unique_ptr< integer_type > x)
  {
    this->integer_.set (std::move (x));
  }


  // IntegerTimer
  // 

  const IntegerTimer::start_type& IntegerTimer::
  start () const
  {
    return this->start_.get ();
  }

  IntegerTimer::start_type& IntegerTimer::
  start ()
  {
    return this->start_.get ();
  }

  void IntegerTimer::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void IntegerTimer::
  start (::std::unique_ptr< start_type > x)
  {
    this->start_.set (std::move (x));
  }

  const IntegerTimer::end_optional& IntegerTimer::
  end () const
  {
    return this->end_;
  }

  IntegerTimer::end_optional& IntegerTimer::
  end ()
  {
    return this->end_;
  }

  void IntegerTimer::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  void IntegerTimer::
  end (const end_optional& x)
  {
    this->end_ = x;
  }

  void IntegerTimer::
  end (::std::unique_ptr< end_type > x)
  {
    this->end_.set (std::move (x));
  }


  // TimerContext
  // 

  const TimerContext::current_type& TimerContext::
  current () const
  {
    return this->current_.get ();
  }

  TimerContext::current_type& TimerContext::
  current ()
  {
    return this->current_.get ();
  }

  void TimerContext::
  current (const current_type& x)
  {
    this->current_.set (x);
  }

  const TimerContext::start_optional& TimerContext::
  start () const
  {
    return this->start_;
  }

  TimerContext::start_optional& TimerContext::
  start ()
  {
    return this->start_;
  }

  void TimerContext::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void TimerContext::
  start (const start_optional& x)
  {
    this->start_ = x;
  }

  const TimerContext::end_optional& TimerContext::
  end () const
  {
    return this->end_;
  }

  TimerContext::end_optional& TimerContext::
  end ()
  {
    return this->end_;
  }

  void TimerContext::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  void TimerContext::
  end (const end_optional& x)
  {
    this->end_ = x;
  }


  // CheckContext
  // 

  const CheckContext::areaMap_optional& CheckContext::
  areaMap () const
  {
    return this->areaMap_;
  }

  CheckContext::areaMap_optional& CheckContext::
  areaMap ()
  {
    return this->areaMap_;
  }

  void CheckContext::
  areaMap (const areaMap_type& x)
  {
    this->areaMap_.set (x);
  }

  void CheckContext::
  areaMap (const areaMap_optional& x)
  {
    this->areaMap_ = x;
  }

  void CheckContext::
  areaMap (::std::unique_ptr< areaMap_type > x)
  {
    this->areaMap_.set (std::move (x));
  }

  const CheckContext::computationMask_optional& CheckContext::
  computationMask () const
  {
    return this->computationMask_;
  }

  CheckContext::computationMask_optional& CheckContext::
  computationMask ()
  {
    return this->computationMask_;
  }

  void CheckContext::
  computationMask (const computationMask_type& x)
  {
    this->computationMask_.set (x);
  }

  void CheckContext::
  computationMask (const computationMask_optional& x)
  {
    this->computationMask_ = x;
  }

  void CheckContext::
  computationMask (::std::unique_ptr< computationMask_type > x)
  {
    this->computationMask_.set (std::move (x));
  }

  const CheckContext::timer_optional& CheckContext::
  timer () const
  {
    return this->timer_;
  }

  CheckContext::timer_optional& CheckContext::
  timer ()
  {
    return this->timer_;
  }

  void CheckContext::
  timer (const timer_type& x)
  {
    this->timer_.set (x);
  }

  void CheckContext::
  timer (const timer_optional& x)
  {
    this->timer_ = x;
  }

  void CheckContext::
  timer (::std::unique_ptr< timer_type > x)
  {
    this->timer_.set (std::move (x));
  }


  // RunContext
  // 

  const RunContext::areaMap_type& RunContext::
  areaMap () const
  {
    return this->areaMap_.get ();
  }

  RunContext::areaMap_type& RunContext::
  areaMap ()
  {
    return this->areaMap_.get ();
  }

  void RunContext::
  areaMap (const areaMap_type& x)
  {
    this->areaMap_.set (x);
  }

  void RunContext::
  areaMap (::std::unique_ptr< areaMap_type > x)
  {
    this->areaMap_.set (std::move (x));
  }

  const RunContext::computationMask_optional& RunContext::
  computationMask () const
  {
    return this->computationMask_;
  }

  RunContext::computationMask_optional& RunContext::
  computationMask ()
  {
    return this->computationMask_;
  }

  void RunContext::
  computationMask (const computationMask_type& x)
  {
    this->computationMask_.set (x);
  }

  void RunContext::
  computationMask (const computationMask_optional& x)
  {
    this->computationMask_ = x;
  }

  void RunContext::
  computationMask (::std::unique_ptr< computationMask_type > x)
  {
    this->computationMask_.set (std::move (x));
  }

  const RunContext::timer_type& RunContext::
  timer () const
  {
    return this->timer_.get ();
  }

  RunContext::timer_type& RunContext::
  timer ()
  {
    return this->timer_.get ();
  }

  void RunContext::
  timer (const timer_type& x)
  {
    this->timer_.set (x);
  }

  void RunContext::
  timer (::std::unique_ptr< timer_type > x)
  {
    this->timer_.set (std::move (x));
  }


  // LinkInLibraryManifest
  // 

  const LinkInLibraryManifest::function_sequence& LinkInLibraryManifest::
  function () const
  {
    return this->function_;
  }

  LinkInLibraryManifest::function_sequence& LinkInLibraryManifest::
  function ()
  {
    return this->function_;
  }

  void LinkInLibraryManifest::
  function (const function_sequence& s)
  {
    this->function_ = s;
  }

  const LinkInLibraryManifest::class_sequence& LinkInLibraryManifest::
  class_ () const
  {
    return this->class__;
  }

  LinkInLibraryManifest::class_sequence& LinkInLibraryManifest::
  class_ ()
  {
    return this->class__;
  }

  void LinkInLibraryManifest::
  class_ (const class_sequence& s)
  {
    this->class__ = s;
  }


  // LinkInClassManifest
  // 

  const LinkInClassManifest::name_type& LinkInClassManifest::
  name () const
  {
    return this->name_.get ();
  }

  LinkInClassManifest::name_type& LinkInClassManifest::
  name ()
  {
    return this->name_.get ();
  }

  void LinkInClassManifest::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void LinkInClassManifest::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const LinkInClassManifest::constructor_type& LinkInClassManifest::
  constructor () const
  {
    return this->constructor_.get ();
  }

  LinkInClassManifest::constructor_type& LinkInClassManifest::
  constructor ()
  {
    return this->constructor_.get ();
  }

  void LinkInClassManifest::
  constructor (const constructor_type& x)
  {
    this->constructor_.set (x);
  }

  void LinkInClassManifest::
  constructor (::std::unique_ptr< constructor_type > x)
  {
    this->constructor_.set (std::move (x));
  }

  const LinkInClassManifest::method_sequence& LinkInClassManifest::
  method () const
  {
    return this->method_;
  }

  LinkInClassManifest::method_sequence& LinkInClassManifest::
  method ()
  {
    return this->method_;
  }

  void LinkInClassManifest::
  method (const method_sequence& s)
  {
    this->method_ = s;
  }


  // LinkInClassConstructor
  // 

  const LinkInClassConstructor::stringArgument_optional& LinkInClassConstructor::
  stringArgument () const
  {
    return this->stringArgument_;
  }

  LinkInClassConstructor::stringArgument_optional& LinkInClassConstructor::
  stringArgument ()
  {
    return this->stringArgument_;
  }

  void LinkInClassConstructor::
  stringArgument (const stringArgument_type& x)
  {
    this->stringArgument_.set (x);
  }

  void LinkInClassConstructor::
  stringArgument (const stringArgument_optional& x)
  {
    this->stringArgument_ = x;
  }

  void LinkInClassConstructor::
  stringArgument (::std::unique_ptr< stringArgument_type > x)
  {
    this->stringArgument_.set (std::move (x));
  }

  const LinkInClassConstructor::argument_sequence& LinkInClassConstructor::
  argument () const
  {
    return this->argument_;
  }

  LinkInClassConstructor::argument_sequence& LinkInClassConstructor::
  argument ()
  {
    return this->argument_;
  }

  void LinkInClassConstructor::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }


  // FieldType
  // 

  const FieldType::dataType_type& FieldType::
  dataType () const
  {
    return this->dataType_.get ();
  }

  FieldType::dataType_type& FieldType::
  dataType ()
  {
    return this->dataType_.get ();
  }

  void FieldType::
  dataType (const dataType_type& x)
  {
    this->dataType_.set (x);
  }

  void FieldType::
  dataType (::std::unique_ptr< dataType_type > x)
  {
    this->dataType_.set (std::move (x));
  }

  const FieldType::spatialType_type& FieldType::
  spatialType () const
  {
    return this->spatialType_.get ();
  }

  FieldType::spatialType_type& FieldType::
  spatialType ()
  {
    return this->spatialType_.get ();
  }

  void FieldType::
  spatialType (const spatialType_type& x)
  {
    this->spatialType_.set (x);
  }

  void FieldType::
  spatialType (::std::unique_ptr< spatialType_type > x)
  {
    this->spatialType_.set (std::move (x));
  }


  // FieldTypeOfValue
  // 

  const FieldTypeOfValue::dataType_type& FieldTypeOfValue::
  dataType () const
  {
    return this->dataType_.get ();
  }

  FieldTypeOfValue::dataType_type& FieldTypeOfValue::
  dataType ()
  {
    return this->dataType_.get ();
  }

  void FieldTypeOfValue::
  dataType (const dataType_type& x)
  {
    this->dataType_.set (x);
  }

  void FieldTypeOfValue::
  dataType (::std::unique_ptr< dataType_type > x)
  {
    this->dataType_.set (std::move (x));
  }

  const FieldTypeOfValue::spatialType_type& FieldTypeOfValue::
  spatialType () const
  {
    return this->spatialType_.get ();
  }

  FieldTypeOfValue::spatialType_type& FieldTypeOfValue::
  spatialType ()
  {
    return this->spatialType_.get ();
  }

  void FieldTypeOfValue::
  spatialType (const spatialType_type& x)
  {
    this->spatialType_.set (x);
  }

  void FieldTypeOfValue::
  spatialType (::std::unique_ptr< spatialType_type > x)
  {
    this->spatialType_.set (std::move (x));
  }


  // LinkInClassMethod
  // 

  const LinkInClassMethod::name_type& LinkInClassMethod::
  name () const
  {
    return this->name_.get ();
  }

  LinkInClassMethod::name_type& LinkInClassMethod::
  name ()
  {
    return this->name_.get ();
  }

  void LinkInClassMethod::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void LinkInClassMethod::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const LinkInClassMethod::result_sequence& LinkInClassMethod::
  result () const
  {
    return this->result_;
  }

  LinkInClassMethod::result_sequence& LinkInClassMethod::
  result ()
  {
    return this->result_;
  }

  void LinkInClassMethod::
  result (const result_sequence& s)
  {
    this->result_ = s;
  }

  const LinkInClassMethod::stringArgument_optional& LinkInClassMethod::
  stringArgument () const
  {
    return this->stringArgument_;
  }

  LinkInClassMethod::stringArgument_optional& LinkInClassMethod::
  stringArgument ()
  {
    return this->stringArgument_;
  }

  void LinkInClassMethod::
  stringArgument (const stringArgument_type& x)
  {
    this->stringArgument_.set (x);
  }

  void LinkInClassMethod::
  stringArgument (const stringArgument_optional& x)
  {
    this->stringArgument_ = x;
  }

  void LinkInClassMethod::
  stringArgument (::std::unique_ptr< stringArgument_type > x)
  {
    this->stringArgument_.set (std::move (x));
  }

  const LinkInClassMethod::argument_sequence& LinkInClassMethod::
  argument () const
  {
    return this->argument_;
  }

  LinkInClassMethod::argument_sequence& LinkInClassMethod::
  argument ()
  {
    return this->argument_;
  }

  void LinkInClassMethod::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }


  // LinkInFunctionManifest
  // 

  const LinkInFunctionManifest::name_type& LinkInFunctionManifest::
  name () const
  {
    return this->name_.get ();
  }

  LinkInFunctionManifest::name_type& LinkInFunctionManifest::
  name ()
  {
    return this->name_.get ();
  }

  void LinkInFunctionManifest::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void LinkInFunctionManifest::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const LinkInFunctionManifest::result_sequence& LinkInFunctionManifest::
  result () const
  {
    return this->result_;
  }

  LinkInFunctionManifest::result_sequence& LinkInFunctionManifest::
  result ()
  {
    return this->result_;
  }

  void LinkInFunctionManifest::
  result (const result_sequence& s)
  {
    this->result_ = s;
  }

  const LinkInFunctionManifest::stringArgument_optional& LinkInFunctionManifest::
  stringArgument () const
  {
    return this->stringArgument_;
  }

  LinkInFunctionManifest::stringArgument_optional& LinkInFunctionManifest::
  stringArgument ()
  {
    return this->stringArgument_;
  }

  void LinkInFunctionManifest::
  stringArgument (const stringArgument_type& x)
  {
    this->stringArgument_.set (x);
  }

  void LinkInFunctionManifest::
  stringArgument (const stringArgument_optional& x)
  {
    this->stringArgument_ = x;
  }

  void LinkInFunctionManifest::
  stringArgument (::std::unique_ptr< stringArgument_type > x)
  {
    this->stringArgument_.set (std::move (x));
  }

  const LinkInFunctionManifest::argument_sequence& LinkInFunctionManifest::
  argument () const
  {
    return this->argument_;
  }

  LinkInFunctionManifest::argument_sequence& LinkInFunctionManifest::
  argument ()
  {
    return this->argument_;
  }

  void LinkInFunctionManifest::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }


  // CallPoint
  // 

  const CallPoint::object_optional& CallPoint::
  object () const
  {
    return this->object_;
  }

  CallPoint::object_optional& CallPoint::
  object ()
  {
    return this->object_;
  }

  void CallPoint::
  object (const object_type& x)
  {
    this->object_.set (x);
  }

  void CallPoint::
  object (const object_optional& x)
  {
    this->object_ = x;
  }

  void CallPoint::
  object (::std::unique_ptr< object_type > x)
  {
    this->object_.set (std::move (x));
  }

  const CallPoint::function_optional& CallPoint::
  function () const
  {
    return this->function_;
  }

  CallPoint::function_optional& CallPoint::
  function ()
  {
    return this->function_;
  }

  void CallPoint::
  function (const function_type& x)
  {
    this->function_.set (x);
  }

  void CallPoint::
  function (const function_optional& x)
  {
    this->function_ = x;
  }

  void CallPoint::
  function (::std::unique_ptr< function_type > x)
  {
    this->function_.set (std::move (x));
  }


  // LinkInCheckInput
  // 

  const LinkInCheckInput::context_type& LinkInCheckInput::
  context () const
  {
    return this->context_.get ();
  }

  LinkInCheckInput::context_type& LinkInCheckInput::
  context ()
  {
    return this->context_.get ();
  }

  void LinkInCheckInput::
  context (const context_type& x)
  {
    this->context_.set (x);
  }

  void LinkInCheckInput::
  context (::std::unique_ptr< context_type > x)
  {
    this->context_.set (std::move (x));
  }

  const LinkInCheckInput::callPoint_type& LinkInCheckInput::
  callPoint () const
  {
    return this->callPoint_.get ();
  }

  LinkInCheckInput::callPoint_type& LinkInCheckInput::
  callPoint ()
  {
    return this->callPoint_.get ();
  }

  void LinkInCheckInput::
  callPoint (const callPoint_type& x)
  {
    this->callPoint_.set (x);
  }

  void LinkInCheckInput::
  callPoint (::std::unique_ptr< callPoint_type > x)
  {
    this->callPoint_.set (std::move (x));
  }

  const LinkInCheckInput::result_sequence& LinkInCheckInput::
  result () const
  {
    return this->result_;
  }

  LinkInCheckInput::result_sequence& LinkInCheckInput::
  result ()
  {
    return this->result_;
  }

  void LinkInCheckInput::
  result (const result_sequence& s)
  {
    this->result_ = s;
  }

  const LinkInCheckInput::stringArgument_optional& LinkInCheckInput::
  stringArgument () const
  {
    return this->stringArgument_;
  }

  LinkInCheckInput::stringArgument_optional& LinkInCheckInput::
  stringArgument ()
  {
    return this->stringArgument_;
  }

  void LinkInCheckInput::
  stringArgument (const stringArgument_type& x)
  {
    this->stringArgument_.set (x);
  }

  void LinkInCheckInput::
  stringArgument (const stringArgument_optional& x)
  {
    this->stringArgument_ = x;
  }

  void LinkInCheckInput::
  stringArgument (::std::unique_ptr< stringArgument_type > x)
  {
    this->stringArgument_.set (std::move (x));
  }

  const LinkInCheckInput::argument_sequence& LinkInCheckInput::
  argument () const
  {
    return this->argument_;
  }

  LinkInCheckInput::argument_sequence& LinkInCheckInput::
  argument ()
  {
    return this->argument_;
  }

  void LinkInCheckInput::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }


  // LinkInCheckResult
  // 

  const LinkInCheckResult::error_optional& LinkInCheckResult::
  error () const
  {
    return this->error_;
  }

  LinkInCheckResult::error_optional& LinkInCheckResult::
  error ()
  {
    return this->error_;
  }

  void LinkInCheckResult::
  error (const error_type& x)
  {
    this->error_.set (x);
  }

  void LinkInCheckResult::
  error (const error_optional& x)
  {
    this->error_ = x;
  }

  void LinkInCheckResult::
  error (::std::unique_ptr< error_type > x)
  {
    this->error_.set (std::move (x));
  }

  const LinkInCheckResult::result_sequence& LinkInCheckResult::
  result () const
  {
    return this->result_;
  }

  LinkInCheckResult::result_sequence& LinkInCheckResult::
  result ()
  {
    return this->result_;
  }

  void LinkInCheckResult::
  result (const result_sequence& s)
  {
    this->result_ = s;
  }

  const LinkInCheckResult::argument_sequence& LinkInCheckResult::
  argument () const
  {
    return this->argument_;
  }

  LinkInCheckResult::argument_sequence& LinkInCheckResult::
  argument ()
  {
    return this->argument_;
  }

  void LinkInCheckResult::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }


  // LinkInExecuteInput
  // 

  const LinkInExecuteInput::context_type& LinkInExecuteInput::
  context () const
  {
    return this->context_.get ();
  }

  LinkInExecuteInput::context_type& LinkInExecuteInput::
  context ()
  {
    return this->context_.get ();
  }

  void LinkInExecuteInput::
  context (const context_type& x)
  {
    this->context_.set (x);
  }

  void LinkInExecuteInput::
  context (::std::unique_ptr< context_type > x)
  {
    this->context_.set (std::move (x));
  }

  const LinkInExecuteInput::callPoint_type& LinkInExecuteInput::
  callPoint () const
  {
    return this->callPoint_.get ();
  }

  LinkInExecuteInput::callPoint_type& LinkInExecuteInput::
  callPoint ()
  {
    return this->callPoint_.get ();
  }

  void LinkInExecuteInput::
  callPoint (const callPoint_type& x)
  {
    this->callPoint_.set (x);
  }

  void LinkInExecuteInput::
  callPoint (::std::unique_ptr< callPoint_type > x)
  {
    this->callPoint_.set (std::move (x));
  }

  const LinkInExecuteInput::result_sequence& LinkInExecuteInput::
  result () const
  {
    return this->result_;
  }

  LinkInExecuteInput::result_sequence& LinkInExecuteInput::
  result ()
  {
    return this->result_;
  }

  void LinkInExecuteInput::
  result (const result_sequence& s)
  {
    this->result_ = s;
  }

  const LinkInExecuteInput::stringArgument_optional& LinkInExecuteInput::
  stringArgument () const
  {
    return this->stringArgument_;
  }

  LinkInExecuteInput::stringArgument_optional& LinkInExecuteInput::
  stringArgument ()
  {
    return this->stringArgument_;
  }

  void LinkInExecuteInput::
  stringArgument (const stringArgument_type& x)
  {
    this->stringArgument_.set (x);
  }

  void LinkInExecuteInput::
  stringArgument (const stringArgument_optional& x)
  {
    this->stringArgument_ = x;
  }

  void LinkInExecuteInput::
  stringArgument (::std::unique_ptr< stringArgument_type > x)
  {
    this->stringArgument_.set (std::move (x));
  }

  const LinkInExecuteInput::argument_sequence& LinkInExecuteInput::
  argument () const
  {
    return this->argument_;
  }

  LinkInExecuteInput::argument_sequence& LinkInExecuteInput::
  argument ()
  {
    return this->argument_;
  }

  void LinkInExecuteInput::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }


  // LinkInExecuteResult
  // 

  const LinkInExecuteResult::error_optional& LinkInExecuteResult::
  error () const
  {
    return this->error_;
  }

  LinkInExecuteResult::error_optional& LinkInExecuteResult::
  error ()
  {
    return this->error_;
  }

  void LinkInExecuteResult::
  error (const error_type& x)
  {
    this->error_.set (x);
  }

  void LinkInExecuteResult::
  error (const error_optional& x)
  {
    this->error_ = x;
  }

  void LinkInExecuteResult::
  error (::std::unique_ptr< error_type > x)
  {
    this->error_.set (std::move (x));
  }


  // object
  // 

  const object::className_type& object::
  className () const
  {
    return this->className_.get ();
  }

  object::className_type& object::
  className ()
  {
    return this->className_.get ();
  }

  void object::
  className (const className_type& x)
  {
    this->className_.set (x);
  }

  void object::
  className (::std::unique_ptr< className_type > x)
  {
    this->className_.set (std::move (x));
  }

  const object::objectName_type& object::
  objectName () const
  {
    return this->objectName_.get ();
  }

  object::objectName_type& object::
  objectName ()
  {
    return this->objectName_.get ();
  }

  void object::
  objectName (const objectName_type& x)
  {
    this->objectName_.set (x);
  }

  void object::
  objectName (::std::unique_ptr< objectName_type > x)
  {
    this->objectName_.set (std::move (x));
  }

  const object::constructor_optional& object::
  constructor () const
  {
    return this->constructor_;
  }

  object::constructor_optional& object::
  constructor ()
  {
    return this->constructor_;
  }

  void object::
  constructor (const constructor_type& x)
  {
    this->constructor_.set (x);
  }

  void object::
  constructor (const constructor_optional& x)
  {
    this->constructor_ = x;
  }

  void object::
  constructor (::std::unique_ptr< constructor_type > x)
  {
    this->constructor_.set (std::move (x));
  }

  const object::methodName_optional& object::
  methodName () const
  {
    return this->methodName_;
  }

  object::methodName_optional& object::
  methodName ()
  {
    return this->methodName_;
  }

  void object::
  methodName (const methodName_type& x)
  {
    this->methodName_.set (x);
  }

  void object::
  methodName (const methodName_optional& x)
  {
    this->methodName_ = x;
  }

  void object::
  methodName (::std::unique_ptr< methodName_type > x)
  {
    this->methodName_.set (std::move (x));
  }


  // function
  // 

  const function::name_type& function::
  name () const
  {
    return this->name_.get ();
  }

  function::name_type& function::
  name ()
  {
    return this->name_.get ();
  }

  void function::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void function::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace pcrxml
{
  // SpatialType
  //

  SpatialType::
  SpatialType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_SpatialType_convert ();
  }

  SpatialType::
  SpatialType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_SpatialType_convert ();
  }

  SpatialType::
  SpatialType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_SpatialType_convert ();
  }

  SpatialType* SpatialType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpatialType (*this, f, c);
  }

  SpatialType::value SpatialType::
  _xsd_SpatialType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SpatialType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_SpatialType_indexes_,
                      _xsd_SpatialType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_SpatialType_indexes_ + 3 || _xsd_SpatialType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SpatialType::
  _xsd_SpatialType_literals_[3] =
  {
    "Spatial",
    "NonSpatial",
    "Either"
  };

  const SpatialType::value SpatialType::
  _xsd_SpatialType_indexes_[3] =
  {
    ::pcrxml::SpatialType::Either,
    ::pcrxml::SpatialType::NonSpatial,
    ::pcrxml::SpatialType::Spatial
  };

  // SpatialTypeOfValue
  //

  SpatialTypeOfValue::
  SpatialTypeOfValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::pcrxml::SpatialType (e, f, c)
  {
    _xsd_SpatialTypeOfValue_convert ();
  }

  SpatialTypeOfValue::
  SpatialTypeOfValue (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::pcrxml::SpatialType (a, f, c)
  {
    _xsd_SpatialTypeOfValue_convert ();
  }

  SpatialTypeOfValue::
  SpatialTypeOfValue (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::pcrxml::SpatialType (s, e, f, c)
  {
    _xsd_SpatialTypeOfValue_convert ();
  }

  SpatialTypeOfValue* SpatialTypeOfValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpatialTypeOfValue (*this, f, c);
  }

  SpatialTypeOfValue::value SpatialTypeOfValue::
  _xsd_SpatialTypeOfValue_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SpatialTypeOfValue_literals_);
    const value* i (::std::lower_bound (
                      _xsd_SpatialTypeOfValue_indexes_,
                      _xsd_SpatialTypeOfValue_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_SpatialTypeOfValue_indexes_ + 2 || _xsd_SpatialTypeOfValue_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const* SpatialTypeOfValue::
  _xsd_SpatialTypeOfValue_literals_ = ::pcrxml::SpatialType::_xsd_SpatialType_literals_;

  const SpatialTypeOfValue::value SpatialTypeOfValue::
  _xsd_SpatialTypeOfValue_indexes_[2] =
  {
    ::pcrxml::SpatialTypeOfValue::NonSpatial,
    ::pcrxml::SpatialTypeOfValue::Spatial
  };

  // MemoryExchange
  //

  MemoryExchange::
  MemoryExchange (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  MemoryExchange::
  MemoryExchange (const MemoryExchange& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  MemoryExchange::
  MemoryExchange (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  MemoryExchange::
  MemoryExchange (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  MemoryExchange::
  MemoryExchange (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  MemoryExchange* MemoryExchange::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MemoryExchange (*this, f, c);
  }

  MemoryExchange::
  ~MemoryExchange ()
  {
  }

  // Exchange
  //

  Exchange::
  Exchange ()
  : ::xml_schema::type (),
    external_ (this),
    memoryExchange_ (this)
  {
  }

  Exchange::
  Exchange (const Exchange& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    external_ (x.external_, f, this),
    memoryExchange_ (x.memoryExchange_, f, this)
  {
  }

  Exchange::
  Exchange (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    external_ (this),
    memoryExchange_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Exchange::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // external
      //
      if (n.name () == "external" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< external_type > r (
          external_traits::create (i, f, this));

        if (!this->external_)
        {
          this->external_.set (::std::move (r));
          continue;
        }
      }

      // memoryExchange
      //
      if (n.name () == "memoryExchange" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< memoryExchange_type > r (
          memoryExchange_traits::create (i, f, this));

        if (!this->memoryExchange_)
        {
          this->memoryExchange_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Exchange* Exchange::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Exchange (*this, f, c);
  }

  Exchange& Exchange::
  operator= (const Exchange& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->external_ = x.external_;
      this->memoryExchange_ = x.memoryExchange_;
    }

    return *this;
  }

  Exchange::
  ~Exchange ()
  {
  }

  // Description
  //

  Description::
  Description (const text_type& text)
  : ::xml_schema::type (),
    text_ (text, this)
  {
  }

  Description::
  Description (const Description& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    text_ (x.text_, f, this)
  {
  }

  Description::
  Description (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    text_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Description::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // text
      //
      if (n.name () == "text" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< text_type > r (
          text_traits::create (i, f, this));

        if (!text_.present ())
        {
          this->text_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!text_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "text",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  Description* Description::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Description (*this, f, c);
  }

  Description& Description::
  operator= (const Description& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->text_ = x.text_;
    }

    return *this;
  }

  Description::
  ~Description ()
  {
  }

  // ModelInputType
  //

  ModelInputType::
  ModelInputType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ModelInputType_convert ();
  }

  ModelInputType::
  ModelInputType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ModelInputType_convert ();
  }

  ModelInputType::
  ModelInputType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ModelInputType_convert ();
  }

  ModelInputType* ModelInputType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ModelInputType (*this, f, c);
  }

  ModelInputType::value ModelInputType::
  _xsd_ModelInputType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ModelInputType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ModelInputType_indexes_,
                      _xsd_ModelInputType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_ModelInputType_indexes_ + 4 || _xsd_ModelInputType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ModelInputType::
  _xsd_ModelInputType_literals_[4] =
  {
    "Constant",
    "None",
    "Initial",
    "Dynamic"
  };

  const ModelInputType::value ModelInputType::
  _xsd_ModelInputType_indexes_[4] =
  {
    ::pcrxml::ModelInputType::Constant,
    ::pcrxml::ModelInputType::Dynamic,
    ::pcrxml::ModelInputType::Initial,
    ::pcrxml::ModelInputType::None
  };

  // ModelOutputType
  //

  ModelOutputType::
  ModelOutputType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ModelOutputType_convert ();
  }

  ModelOutputType::
  ModelOutputType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ModelOutputType_convert ();
  }

  ModelOutputType::
  ModelOutputType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ModelOutputType_convert ();
  }

  ModelOutputType* ModelOutputType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ModelOutputType (*this, f, c);
  }

  ModelOutputType::value ModelOutputType::
  _xsd_ModelOutputType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ModelOutputType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ModelOutputType_indexes_,
                      _xsd_ModelOutputType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_ModelOutputType_indexes_ + 3 || _xsd_ModelOutputType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ModelOutputType::
  _xsd_ModelOutputType_literals_[3] =
  {
    "Fixed",
    "Initial",
    "Dynamic"
  };

  const ModelOutputType::value ModelOutputType::
  _xsd_ModelOutputType_indexes_[3] =
  {
    ::pcrxml::ModelOutputType::Dynamic,
    ::pcrxml::ModelOutputType::Fixed,
    ::pcrxml::ModelOutputType::Initial
  };

  // ModelExchange
  //

  ModelExchange::
  ModelExchange ()
  : ::xml_schema::type (),
    input_ (this),
    output_ (this)
  {
  }

  ModelExchange::
  ModelExchange (const ModelExchange& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this)
  {
  }

  ModelExchange::
  ModelExchange (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    input_ (this),
    output_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ModelExchange::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "input" && n.namespace_ ().empty ())
      {
        this->input_.set (input_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "output" && n.namespace_ ().empty ())
      {
        this->output_.set (output_traits::create (i, f, this));
        continue;
      }
    }
  }

  ModelExchange* ModelExchange::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ModelExchange (*this, f, c);
  }

  ModelExchange& ModelExchange::
  operator= (const ModelExchange& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->input_ = x.input_;
      this->output_ = x.output_;
    }

    return *this;
  }

  ModelExchange::
  ~ModelExchange ()
  {
  }

  // LookupColumn
  //

  LookupColumn::
  LookupColumn ()
  : ::xml_schema::string ()
  {
  }

  LookupColumn::
  LookupColumn (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LookupColumn::
  LookupColumn (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LookupColumn::
  LookupColumn (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LookupColumn::
  LookupColumn (const LookupColumn& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  LookupColumn::
  LookupColumn (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  LookupColumn::
  LookupColumn (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  LookupColumn::
  LookupColumn (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  LookupColumn* LookupColumn::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LookupColumn (*this, f, c);
  }

  LookupColumn::
  ~LookupColumn ()
  {
  }

  // OutputMapFormat
  //

  OutputMapFormat::
  OutputMapFormat ()
  : ::xml_schema::type (),
    pcrasterMapFormat_ (this),
    bandMapFormat_ (this),
    esriGridFormat_ (this)
  {
  }

  OutputMapFormat::
  OutputMapFormat (const OutputMapFormat& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    pcrasterMapFormat_ (x.pcrasterMapFormat_, f, this),
    bandMapFormat_ (x.bandMapFormat_, f, this),
    esriGridFormat_ (x.esriGridFormat_, f, this)
  {
  }

  OutputMapFormat::
  OutputMapFormat (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    pcrasterMapFormat_ (this),
    bandMapFormat_ (this),
    esriGridFormat_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OutputMapFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pcrasterMapFormat
      //
      if (n.name () == "pcrasterMapFormat" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< pcrasterMapFormat_type > r (
          pcrasterMapFormat_traits::create (i, f, this));

        if (!this->pcrasterMapFormat_)
        {
          this->pcrasterMapFormat_.set (::std::move (r));
          continue;
        }
      }

      // bandMapFormat
      //
      if (n.name () == "bandMapFormat" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< bandMapFormat_type > r (
          bandMapFormat_traits::create (i, f, this));

        if (!this->bandMapFormat_)
        {
          this->bandMapFormat_.set (::std::move (r));
          continue;
        }
      }

      // esriGridFormat
      //
      if (n.name () == "esriGridFormat" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< esriGridFormat_type > r (
          esriGridFormat_traits::create (i, f, this));

        if (!this->esriGridFormat_)
        {
          this->esriGridFormat_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OutputMapFormat* OutputMapFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OutputMapFormat (*this, f, c);
  }

  OutputMapFormat& OutputMapFormat::
  operator= (const OutputMapFormat& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->pcrasterMapFormat_ = x.pcrasterMapFormat_;
      this->bandMapFormat_ = x.bandMapFormat_;
      this->esriGridFormat_ = x.esriGridFormat_;
    }

    return *this;
  }

  OutputMapFormat::
  ~OutputMapFormat ()
  {
  }

  // CellCoordinate
  //

  CellCoordinate::
  CellCoordinate (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_CellCoordinate_convert ();
  }

  CellCoordinate::
  CellCoordinate (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_CellCoordinate_convert ();
  }

  CellCoordinate::
  CellCoordinate (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_CellCoordinate_convert ();
  }

  CellCoordinate* CellCoordinate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CellCoordinate (*this, f, c);
  }

  CellCoordinate::value CellCoordinate::
  _xsd_CellCoordinate_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CellCoordinate_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CellCoordinate_indexes_,
                      _xsd_CellCoordinate_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CellCoordinate_indexes_ + 3 || _xsd_CellCoordinate_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CellCoordinate::
  _xsd_CellCoordinate_literals_[3] =
  {
    "Centre",
    "UpperLeft",
    "LowerRight"
  };

  const CellCoordinate::value CellCoordinate::
  _xsd_CellCoordinate_indexes_[3] =
  {
    ::pcrxml::CellCoordinate::Centre,
    ::pcrxml::CellCoordinate::LowerRight,
    ::pcrxml::CellCoordinate::UpperLeft
  };

  // DirectionalValueUnit
  //

  DirectionalValueUnit::
  DirectionalValueUnit (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_DirectionalValueUnit_convert ();
  }

  DirectionalValueUnit::
  DirectionalValueUnit (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_DirectionalValueUnit_convert ();
  }

  DirectionalValueUnit::
  DirectionalValueUnit (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_DirectionalValueUnit_convert ();
  }

  DirectionalValueUnit* DirectionalValueUnit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DirectionalValueUnit (*this, f, c);
  }

  DirectionalValueUnit::value DirectionalValueUnit::
  _xsd_DirectionalValueUnit_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DirectionalValueUnit_literals_);
    const value* i (::std::lower_bound (
                      _xsd_DirectionalValueUnit_indexes_,
                      _xsd_DirectionalValueUnit_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_DirectionalValueUnit_indexes_ + 2 || _xsd_DirectionalValueUnit_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const DirectionalValueUnit::
  _xsd_DirectionalValueUnit_literals_[2] =
  {
    "Degrees",
    "Radians"
  };

  const DirectionalValueUnit::value DirectionalValueUnit::
  _xsd_DirectionalValueUnit_indexes_[2] =
  {
    ::pcrxml::DirectionalValueUnit::Degrees,
    ::pcrxml::DirectionalValueUnit::Radians
  };

  // LddCreateDemMethod
  //

  LddCreateDemMethod::
  LddCreateDemMethod (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_LddCreateDemMethod_convert ();
  }

  LddCreateDemMethod::
  LddCreateDemMethod (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_LddCreateDemMethod_convert ();
  }

  LddCreateDemMethod::
  LddCreateDemMethod (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_LddCreateDemMethod_convert ();
  }

  LddCreateDemMethod* LddCreateDemMethod::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LddCreateDemMethod (*this, f, c);
  }

  LddCreateDemMethod::value LddCreateDemMethod::
  _xsd_LddCreateDemMethod_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LddCreateDemMethod_literals_);
    const value* i (::std::lower_bound (
                      _xsd_LddCreateDemMethod_indexes_,
                      _xsd_LddCreateDemMethod_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_LddCreateDemMethod_indexes_ + 2 || _xsd_LddCreateDemMethod_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const LddCreateDemMethod::
  _xsd_LddCreateDemMethod_literals_[2] =
  {
    "Fill",
    "Cut"
  };

  const LddCreateDemMethod::value LddCreateDemMethod::
  _xsd_LddCreateDemMethod_indexes_[2] =
  {
    ::pcrxml::LddCreateDemMethod::Cut,
    ::pcrxml::LddCreateDemMethod::Fill
  };

  // DynamicWaveRoughness
  //

  DynamicWaveRoughness::
  DynamicWaveRoughness (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_DynamicWaveRoughness_convert ();
  }

  DynamicWaveRoughness::
  DynamicWaveRoughness (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_DynamicWaveRoughness_convert ();
  }

  DynamicWaveRoughness::
  DynamicWaveRoughness (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_DynamicWaveRoughness_convert ();
  }

  DynamicWaveRoughness* DynamicWaveRoughness::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DynamicWaveRoughness (*this, f, c);
  }

  DynamicWaveRoughness::value DynamicWaveRoughness::
  _xsd_DynamicWaveRoughness_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DynamicWaveRoughness_literals_);
    const value* i (::std::lower_bound (
                      _xsd_DynamicWaveRoughness_indexes_,
                      _xsd_DynamicWaveRoughness_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_DynamicWaveRoughness_indexes_ + 2 || _xsd_DynamicWaveRoughness_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const DynamicWaveRoughness::
  _xsd_DynamicWaveRoughness_literals_[2] =
  {
    "Manning",
    "Chezy"
  };

  const DynamicWaveRoughness::value DynamicWaveRoughness::
  _xsd_DynamicWaveRoughness_indexes_[2] =
  {
    ::pcrxml::DynamicWaveRoughness::Chezy,
    ::pcrxml::DynamicWaveRoughness::Manning
  };

  // ExecutionOptions
  //

  ExecutionOptions::
  ExecutionOptions ()
  : ::xml_schema::type (),
    outputMapFormat_ (this),
    diagonal_ (this),
    twoColumnTableAsMatrix_ (this),
    keepEdgePits_ (this),
    trueCellUnits_ (this),
    cellCoordinate_ (this),
    directionalValueUnit_ (this),
    lddCreateDemMethod_ (this),
    dynamicWaveRoughness_ (this),
    runDirectory_ (this),
    randomGeneratorSeed_ (this),
    maskCompression_ (this),
    useDiskStorage_ (this)
  {
  }

  ExecutionOptions::
  ExecutionOptions (const ExecutionOptions& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    outputMapFormat_ (x.outputMapFormat_, f, this),
    diagonal_ (x.diagonal_, f, this),
    twoColumnTableAsMatrix_ (x.twoColumnTableAsMatrix_, f, this),
    keepEdgePits_ (x.keepEdgePits_, f, this),
    trueCellUnits_ (x.trueCellUnits_, f, this),
    cellCoordinate_ (x.cellCoordinate_, f, this),
    directionalValueUnit_ (x.directionalValueUnit_, f, this),
    lddCreateDemMethod_ (x.lddCreateDemMethod_, f, this),
    dynamicWaveRoughness_ (x.dynamicWaveRoughness_, f, this),
    runDirectory_ (x.runDirectory_, f, this),
    randomGeneratorSeed_ (x.randomGeneratorSeed_, f, this),
    maskCompression_ (x.maskCompression_, f, this),
    useDiskStorage_ (x.useDiskStorage_, f, this)
  {
  }

  ExecutionOptions::
  ExecutionOptions (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    outputMapFormat_ (this),
    diagonal_ (this),
    twoColumnTableAsMatrix_ (this),
    keepEdgePits_ (this),
    trueCellUnits_ (this),
    cellCoordinate_ (this),
    directionalValueUnit_ (this),
    lddCreateDemMethod_ (this),
    dynamicWaveRoughness_ (this),
    runDirectory_ (this),
    randomGeneratorSeed_ (this),
    maskCompression_ (this),
    useDiskStorage_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ExecutionOptions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // outputMapFormat
      //
      if (n.name () == "outputMapFormat" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< outputMapFormat_type > r (
          outputMapFormat_traits::create (i, f, this));

        if (!this->outputMapFormat_)
        {
          this->outputMapFormat_.set (::std::move (r));
          continue;
        }
      }

      // diagonal
      //
      if (n.name () == "diagonal" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->diagonal_)
        {
          this->diagonal_.set (diagonal_traits::create (i, f, this));
          continue;
        }
      }

      // twoColumnTableAsMatrix
      //
      if (n.name () == "twoColumnTableAsMatrix" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->twoColumnTableAsMatrix_)
        {
          this->twoColumnTableAsMatrix_.set (twoColumnTableAsMatrix_traits::create (i, f, this));
          continue;
        }
      }

      // keepEdgePits
      //
      if (n.name () == "keepEdgePits" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->keepEdgePits_)
        {
          this->keepEdgePits_.set (keepEdgePits_traits::create (i, f, this));
          continue;
        }
      }

      // trueCellUnits
      //
      if (n.name () == "trueCellUnits" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->trueCellUnits_)
        {
          this->trueCellUnits_.set (trueCellUnits_traits::create (i, f, this));
          continue;
        }
      }

      // cellCoordinate
      //
      if (n.name () == "cellCoordinate" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< cellCoordinate_type > r (
          cellCoordinate_traits::create (i, f, this));

        if (!this->cellCoordinate_)
        {
          this->cellCoordinate_.set (::std::move (r));
          continue;
        }
      }

      // directionalValueUnit
      //
      if (n.name () == "directionalValueUnit" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< directionalValueUnit_type > r (
          directionalValueUnit_traits::create (i, f, this));

        if (!this->directionalValueUnit_)
        {
          this->directionalValueUnit_.set (::std::move (r));
          continue;
        }
      }

      // lddCreateDemMethod
      //
      if (n.name () == "lddCreateDemMethod" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< lddCreateDemMethod_type > r (
          lddCreateDemMethod_traits::create (i, f, this));

        if (!this->lddCreateDemMethod_)
        {
          this->lddCreateDemMethod_.set (::std::move (r));
          continue;
        }
      }

      // dynamicWaveRoughness
      //
      if (n.name () == "dynamicWaveRoughness" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< dynamicWaveRoughness_type > r (
          dynamicWaveRoughness_traits::create (i, f, this));

        if (!this->dynamicWaveRoughness_)
        {
          this->dynamicWaveRoughness_.set (::std::move (r));
          continue;
        }
      }

      // runDirectory
      //
      if (n.name () == "runDirectory" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< runDirectory_type > r (
          runDirectory_traits::create (i, f, this));

        if (!this->runDirectory_)
        {
          this->runDirectory_.set (::std::move (r));
          continue;
        }
      }

      // randomGeneratorSeed
      //
      if (n.name () == "randomGeneratorSeed" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< randomGeneratorSeed_type > r (
          randomGeneratorSeed_traits::create (i, f, this));

        if (!this->randomGeneratorSeed_)
        {
          this->randomGeneratorSeed_.set (::std::move (r));
          continue;
        }
      }

      // maskCompression
      //
      if (n.name () == "maskCompression" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< maskCompression_type > r (
          maskCompression_traits::create (i, f, this));

        if (!this->maskCompression_)
        {
          this->maskCompression_.set (::std::move (r));
          continue;
        }
      }

      // useDiskStorage
      //
      if (n.name () == "useDiskStorage" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< useDiskStorage_type > r (
          useDiskStorage_traits::create (i, f, this));

        if (!this->useDiskStorage_)
        {
          this->useDiskStorage_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ExecutionOptions* ExecutionOptions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExecutionOptions (*this, f, c);
  }

  ExecutionOptions& ExecutionOptions::
  operator= (const ExecutionOptions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->outputMapFormat_ = x.outputMapFormat_;
      this->diagonal_ = x.diagonal_;
      this->twoColumnTableAsMatrix_ = x.twoColumnTableAsMatrix_;
      this->keepEdgePits_ = x.keepEdgePits_;
      this->trueCellUnits_ = x.trueCellUnits_;
      this->cellCoordinate_ = x.cellCoordinate_;
      this->directionalValueUnit_ = x.directionalValueUnit_;
      this->lddCreateDemMethod_ = x.lddCreateDemMethod_;
      this->dynamicWaveRoughness_ = x.dynamicWaveRoughness_;
      this->runDirectory_ = x.runDirectory_;
      this->randomGeneratorSeed_ = x.randomGeneratorSeed_;
      this->maskCompression_ = x.maskCompression_;
      this->useDiskStorage_ = x.useDiskStorage_;
    }

    return *this;
  }

  ExecutionOptions::
  ~ExecutionOptions ()
  {
  }

  // Script
  //

  Script::
  Script ()
  : ::xml_schema::type (),
    executionOptions_ (this),
    areaMap_ (this),
    computationMask_ (this),
    definition_ (this),
    timer_ (this),
    model_ (this),
    textStatistics_ (this)
  {
  }

  Script::
  Script (const Script& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    executionOptions_ (x.executionOptions_, f, this),
    areaMap_ (x.areaMap_, f, this),
    computationMask_ (x.computationMask_, f, this),
    definition_ (x.definition_, f, this),
    timer_ (x.timer_, f, this),
    model_ (x.model_, f, this),
    textStatistics_ (x.textStatistics_, f, this)
  {
  }

  Script::
  Script (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    executionOptions_ (this),
    areaMap_ (this),
    computationMask_ (this),
    definition_ (this),
    timer_ (this),
    model_ (this),
    textStatistics_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Script::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // executionOptions
      //
      if (n.name () == "executionOptions" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< executionOptions_type > r (
          executionOptions_traits::create (i, f, this));

        if (!this->executionOptions_)
        {
          this->executionOptions_.set (::std::move (r));
          continue;
        }
      }

      // areaMap
      //
      if (n.name () == "areaMap" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< areaMap_type > r (
          areaMap_traits::create (i, f, this));

        if (!this->areaMap_)
        {
          this->areaMap_.set (::std::move (r));
          continue;
        }
      }

      // computationMask
      //
      if (n.name () == "computationMask" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< computationMask_type > r (
          computationMask_traits::create (i, f, this));

        if (!this->computationMask_)
        {
          this->computationMask_.set (::std::move (r));
          continue;
        }
      }

      // definition
      //
      if (n.name () == "definition" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< definition_type > r (
          definition_traits::create (i, f, this));

        this->definition_.push_back (::std::move (r));
        continue;
      }

      // timer
      //
      if (n.name () == "timer" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< timer_type > r (
          timer_traits::create (i, f, this));

        if (!this->timer_)
        {
          this->timer_.set (::std::move (r));
          continue;
        }
      }

      // model
      //
      if (n.name () == "model" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< model_type > r (
          model_traits::create (i, f, this));

        if (!this->model_)
        {
          this->model_.set (::std::move (r));
          continue;
        }
      }

      // textStatistics
      //
      if (n.name () == "textStatistics" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< textStatistics_type > r (
          textStatistics_traits::create (i, f, this));

        this->textStatistics_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Script* Script::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Script (*this, f, c);
  }

  Script& Script::
  operator= (const Script& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->executionOptions_ = x.executionOptions_;
      this->areaMap_ = x.areaMap_;
      this->computationMask_ = x.computationMask_;
      this->definition_ = x.definition_;
      this->timer_ = x.timer_;
      this->model_ = x.model_;
      this->textStatistics_ = x.textStatistics_;
    }

    return *this;
  }

  Script::
  ~Script ()
  {
  }

  // Model
  //

  Model::
  Model (const textModel_type& textModel)
  : ::xml_schema::type (),
    textModel_ (textModel, this)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    textModel_ (x.textModel_, f, this)
  {
  }

  Model::
  Model (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    textModel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // textModel
      //
      if (n.name () == "textModel" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< textModel_type > r (
          textModel_traits::create (i, f, this));

        if (!textModel_.present ())
        {
          this->textModel_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!textModel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "textModel",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  Model* Model::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model& Model::
  operator= (const Model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->textModel_ = x.textModel_;
    }

    return *this;
  }

  Model::
  ~Model ()
  {
  }

  // TextStatisticsSubject
  //

  TextStatisticsSubject::
  TextStatisticsSubject (const fieldRef_type& fieldRef)
  : ::xml_schema::type (),
    fieldRef_ (fieldRef, this),
    intervalRef_ (this)
  {
  }

  TextStatisticsSubject::
  TextStatisticsSubject (const TextStatisticsSubject& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fieldRef_ (x.fieldRef_, f, this),
    intervalRef_ (x.intervalRef_, f, this)
  {
  }

  TextStatisticsSubject::
  TextStatisticsSubject (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fieldRef_ (this),
    intervalRef_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TextStatisticsSubject::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fieldRef" && n.namespace_ ().empty ())
      {
        this->fieldRef_.set (fieldRef_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "intervalRef" && n.namespace_ ().empty ())
      {
        this->intervalRef_.set (intervalRef_traits::create (i, f, this));
        continue;
      }
    }

    if (!fieldRef_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fieldRef",
        "");
    }
  }

  TextStatisticsSubject* TextStatisticsSubject::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TextStatisticsSubject (*this, f, c);
  }

  TextStatisticsSubject& TextStatisticsSubject::
  operator= (const TextStatisticsSubject& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fieldRef_ = x.fieldRef_;
      this->intervalRef_ = x.intervalRef_;
    }

    return *this;
  }

  TextStatisticsSubject::
  ~TextStatisticsSubject ()
  {
  }

  // TextStatistics
  //

  TextStatistics::
  TextStatistics ()
  : ::xml_schema::type (),
    textStatisticsSubject_ (this),
    name_ (this)
  {
  }

  TextStatistics::
  TextStatistics (const TextStatistics& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    textStatisticsSubject_ (x.textStatisticsSubject_, f, this),
    name_ (x.name_, f, this)
  {
  }

  TextStatistics::
  TextStatistics (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    textStatisticsSubject_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TextStatistics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // textStatisticsSubject
      //
      if (n.name () == "textStatisticsSubject" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< textStatisticsSubject_type > r (
          textStatisticsSubject_traits::create (i, f, this));

        this->textStatisticsSubject_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }
  }

  TextStatistics* TextStatistics::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TextStatistics (*this, f, c);
  }

  TextStatistics& TextStatistics::
  operator= (const TextStatistics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->textStatisticsSubject_ = x.textStatisticsSubject_;
      this->name_ = x.name_;
    }

    return *this;
  }

  TextStatistics::
  ~TextStatistics ()
  {
  }

  // LookupRow
  //

  LookupRow::
  LookupRow ()
  : ::xml_schema::type (),
    lookupColumn_ (this)
  {
  }

  LookupRow::
  LookupRow (const LookupRow& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lookupColumn_ (x.lookupColumn_, f, this)
  {
  }

  LookupRow::
  LookupRow (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lookupColumn_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LookupRow::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lookupColumn
      //
      if (n.name () == "lookupColumn" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< lookupColumn_type > r (
          lookupColumn_traits::create (i, f, this));

        this->lookupColumn_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LookupRow* LookupRow::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LookupRow (*this, f, c);
  }

  LookupRow& LookupRow::
  operator= (const LookupRow& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->lookupColumn_ = x.lookupColumn_;
    }

    return *this;
  }

  LookupRow::
  ~LookupRow ()
  {
  }

  // Relation
  //

  Relation::
  Relation ()
  : ::xml_schema::type (),
    lookupTable_ (this),
    indexedArray_ (this)
  {
  }

  Relation::
  Relation (const Relation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lookupTable_ (x.lookupTable_, f, this),
    indexedArray_ (x.indexedArray_, f, this)
  {
  }

  Relation::
  Relation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lookupTable_ (this),
    indexedArray_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Relation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lookupTable
      //
      if (n.name () == "lookupTable" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< lookupTable_type > r (
          lookupTable_traits::create (i, f, this));

        if (!this->lookupTable_)
        {
          this->lookupTable_.set (::std::move (r));
          continue;
        }
      }

      // indexedArray
      //
      if (n.name () == "indexedArray" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< indexedArray_type > r (
          indexedArray_traits::create (i, f, this));

        if (!this->indexedArray_)
        {
          this->indexedArray_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Relation* Relation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Relation (*this, f, c);
  }

  Relation& Relation::
  operator= (const Relation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->lookupTable_ = x.lookupTable_;
      this->indexedArray_ = x.indexedArray_;
    }

    return *this;
  }

  Relation::
  ~Relation ()
  {
  }

  // ArrayDimensionDataType
  //

  ArrayDimensionDataType::
  ArrayDimensionDataType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ArrayDimensionDataType_convert ();
  }

  ArrayDimensionDataType::
  ArrayDimensionDataType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ArrayDimensionDataType_convert ();
  }

  ArrayDimensionDataType::
  ArrayDimensionDataType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ArrayDimensionDataType_convert ();
  }

  ArrayDimensionDataType* ArrayDimensionDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ArrayDimensionDataType (*this, f, c);
  }

  ArrayDimensionDataType::value ArrayDimensionDataType::
  _xsd_ArrayDimensionDataType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ArrayDimensionDataType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ArrayDimensionDataType_indexes_,
                      _xsd_ArrayDimensionDataType_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_ArrayDimensionDataType_indexes_ + 1 || _xsd_ArrayDimensionDataType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ArrayDimensionDataType::
  _xsd_ArrayDimensionDataType_literals_[1] =
  {
    "unsignedInt"
  };

  const ArrayDimensionDataType::value ArrayDimensionDataType::
  _xsd_ArrayDimensionDataType_indexes_[1] =
  {
    ::pcrxml::ArrayDimensionDataType::unsignedInt
  };

  // ArrayValueDataType
  //

  ArrayValueDataType::
  ArrayValueDataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ArrayValueDataType_convert ();
  }

  ArrayValueDataType::
  ArrayValueDataType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ArrayValueDataType_convert ();
  }

  ArrayValueDataType::
  ArrayValueDataType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ArrayValueDataType_convert ();
  }

  ArrayValueDataType* ArrayValueDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ArrayValueDataType (*this, f, c);
  }

  ArrayValueDataType::value ArrayValueDataType::
  _xsd_ArrayValueDataType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ArrayValueDataType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ArrayValueDataType_indexes_,
                      _xsd_ArrayValueDataType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_ArrayValueDataType_indexes_ + 3 || _xsd_ArrayValueDataType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ArrayValueDataType::
  _xsd_ArrayValueDataType_literals_[3] =
  {
    "int",
    "float",
    "double"
  };

  const ArrayValueDataType::value ArrayValueDataType::
  _xsd_ArrayValueDataType_indexes_[3] =
  {
    ::pcrxml::ArrayValueDataType::double_,
    ::pcrxml::ArrayValueDataType::float_,
    ::pcrxml::ArrayValueDataType::int_
  };

  // IndexedArray
  //

  IndexedArray::
  IndexedArray (const dimensionDataType_type& dimensionDataType,
                const valueDataType_type& valueDataType)
  : ::xml_schema::type (),
    dimensionDataType_ (dimensionDataType, this),
    valueDataType_ (valueDataType, this)
  {
  }

  IndexedArray::
  IndexedArray (const IndexedArray& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dimensionDataType_ (x.dimensionDataType_, f, this),
    valueDataType_ (x.valueDataType_, f, this)
  {
  }

  IndexedArray::
  IndexedArray (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dimensionDataType_ (this),
    valueDataType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void IndexedArray::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dimensionDataType
      //
      if (n.name () == "dimensionDataType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< dimensionDataType_type > r (
          dimensionDataType_traits::create (i, f, this));

        if (!dimensionDataType_.present ())
        {
          this->dimensionDataType_.set (::std::move (r));
          continue;
        }
      }

      // valueDataType
      //
      if (n.name () == "valueDataType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< valueDataType_type > r (
          valueDataType_traits::create (i, f, this));

        if (!valueDataType_.present ())
        {
          this->valueDataType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!dimensionDataType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dimensionDataType",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!valueDataType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "valueDataType",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  IndexedArray* IndexedArray::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndexedArray (*this, f, c);
  }

  IndexedArray& IndexedArray::
  operator= (const IndexedArray& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dimensionDataType_ = x.dimensionDataType_;
      this->valueDataType_ = x.valueDataType_;
    }

    return *this;
  }

  IndexedArray::
  ~IndexedArray ()
  {
  }

  // LookupTable
  //

  LookupTable::
  LookupTable ()
  : ::xml_schema::type (),
    lookupRow_ (this)
  {
  }

  LookupTable::
  LookupTable (const LookupTable& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lookupRow_ (x.lookupRow_, f, this)
  {
  }

  LookupTable::
  LookupTable (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lookupRow_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LookupTable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lookupRow
      //
      if (n.name () == "lookupRow" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< lookupRow_type > r (
          lookupRow_traits::create (i, f, this));

        this->lookupRow_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LookupTable* LookupTable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LookupTable (*this, f, c);
  }

  LookupTable& LookupTable::
  operator= (const LookupTable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->lookupRow_ = x.lookupRow_;
    }

    return *this;
  }

  LookupTable::
  ~LookupTable ()
  {
  }

  // FieldValueOrType
  //

  FieldValueOrType::
  FieldValueOrType ()
  : ::xml_schema::type (),
    dataType_ (this),
    number_ (this),
    spatialType_ (this)
  {
  }

  FieldValueOrType::
  FieldValueOrType (const FieldValueOrType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    number_ (x.number_, f, this),
    spatialType_ (x.spatialType_, f, this)
  {
  }

  FieldValueOrType::
  FieldValueOrType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    number_ (this),
    spatialType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FieldValueOrType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        if (!this->dataType_)
        {
          this->dataType_.set (::std::move (r));
          continue;
        }
      }

      // number
      //
      if (n.name () == "number" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->number_)
        {
          this->number_.set (number_traits::create (i, f, this));
          continue;
        }
      }

      // spatialType
      //
      if (n.name () == "spatialType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< spatialType_type > r (
          spatialType_traits::create (i, f, this));

        if (!this->spatialType_)
        {
          this->spatialType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FieldValueOrType* FieldValueOrType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FieldValueOrType (*this, f, c);
  }

  FieldValueOrType& FieldValueOrType::
  operator= (const FieldValueOrType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->number_ = x.number_;
      this->spatialType_ = x.spatialType_;
    }

    return *this;
  }

  FieldValueOrType::
  ~FieldValueOrType ()
  {
  }

  // Definition
  //

  Definition::
  Definition (const name_type& name)
  : ::xml_schema::type (),
    description_ (this),
    field_ (this),
    relation_ (this),
    modelExchange_ (this),
    scriptInput_ (this),
    scriptOutput_ (this),
    name_ (name, this)
  {
  }

  Definition::
  Definition (const Definition& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    field_ (x.field_, f, this),
    relation_ (x.relation_, f, this),
    modelExchange_ (x.modelExchange_, f, this),
    scriptInput_ (x.scriptInput_, f, this),
    scriptOutput_ (x.scriptOutput_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Definition::
  Definition (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (this),
    field_ (this),
    relation_ (this),
    modelExchange_ (this),
    scriptInput_ (this),
    scriptOutput_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Definition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // field
      //
      if (n.name () == "field" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< field_type > r (
          field_traits::create (i, f, this));

        if (!this->field_)
        {
          this->field_.set (::std::move (r));
          continue;
        }
      }

      // relation
      //
      if (n.name () == "relation" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< relation_type > r (
          relation_traits::create (i, f, this));

        if (!this->relation_)
        {
          this->relation_.set (::std::move (r));
          continue;
        }
      }

      // modelExchange
      //
      if (n.name () == "modelExchange" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< modelExchange_type > r (
          modelExchange_traits::create (i, f, this));

        if (!this->modelExchange_)
        {
          this->modelExchange_.set (::std::move (r));
          continue;
        }
      }

      // scriptInput
      //
      if (n.name () == "scriptInput" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< scriptInput_type > r (
          scriptInput_traits::create (i, f, this));

        if (!this->scriptInput_)
        {
          this->scriptInput_.set (::std::move (r));
          continue;
        }
      }

      // scriptOutput
      //
      if (n.name () == "scriptOutput" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< scriptOutput_type > r (
          scriptOutput_traits::create (i, f, this));

        if (!this->scriptOutput_)
        {
          this->scriptOutput_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Definition* Definition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Definition (*this, f, c);
  }

  Definition& Definition::
  operator= (const Definition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->description_ = x.description_;
      this->field_ = x.field_;
      this->relation_ = x.relation_;
      this->modelExchange_ = x.modelExchange_;
      this->scriptInput_ = x.scriptInput_;
      this->scriptOutput_ = x.scriptOutput_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Definition::
  ~Definition ()
  {
  }

  // Boolean
  //

  Boolean::
  Boolean ()
  : ::xml_schema::type ()
  {
  }

  Boolean::
  Boolean (const Boolean& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Boolean::
  Boolean (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Boolean::
  Boolean (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Boolean::
  Boolean (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Boolean* Boolean::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Boolean (*this, f, c);
  }

  Boolean::
  ~Boolean ()
  {
  }

  // Nominal
  //

  Nominal::
  Nominal ()
  : ::xml_schema::type ()
  {
  }

  Nominal::
  Nominal (const Nominal& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Nominal::
  Nominal (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Nominal::
  Nominal (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Nominal::
  Nominal (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Nominal* Nominal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nominal (*this, f, c);
  }

  Nominal::
  ~Nominal ()
  {
  }

  // Ordinal
  //

  Ordinal::
  Ordinal ()
  : ::xml_schema::type ()
  {
  }

  Ordinal::
  Ordinal (const Ordinal& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Ordinal::
  Ordinal (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Ordinal::
  Ordinal (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Ordinal::
  Ordinal (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Ordinal* Ordinal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Ordinal (*this, f, c);
  }

  Ordinal::
  ~Ordinal ()
  {
  }

  // Directional
  //

  Directional::
  Directional ()
  : ::xml_schema::type ()
  {
  }

  Directional::
  Directional (const Directional& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Directional::
  Directional (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Directional::
  Directional (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Directional::
  Directional (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Directional* Directional::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Directional (*this, f, c);
  }

  Directional::
  ~Directional ()
  {
  }

  // Ldd
  //

  Ldd::
  Ldd ()
  : ::xml_schema::type ()
  {
  }

  Ldd::
  Ldd (const Ldd& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Ldd::
  Ldd (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Ldd::
  Ldd (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Ldd::
  Ldd (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Ldd* Ldd::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Ldd (*this, f, c);
  }

  Ldd::
  ~Ldd ()
  {
  }

  // Scalar
  //

  Scalar::
  Scalar ()
  : ::xml_schema::type (),
    length_ (this),
    mass_ (this),
    time_ (this),
    electricCurrent_ (this),
    temperature_ (this),
    amountOfSubstance_ (this),
    luminousIntensity_ (this),
    currency_ (this)
  {
  }

  Scalar::
  Scalar (const Scalar& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    length_ (x.length_, f, this),
    mass_ (x.mass_, f, this),
    time_ (x.time_, f, this),
    electricCurrent_ (x.electricCurrent_, f, this),
    temperature_ (x.temperature_, f, this),
    amountOfSubstance_ (x.amountOfSubstance_, f, this),
    luminousIntensity_ (x.luminousIntensity_, f, this),
    currency_ (x.currency_, f, this)
  {
  }

  Scalar::
  Scalar (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    length_ (this),
    mass_ (this),
    time_ (this),
    electricCurrent_ (this),
    temperature_ (this),
    amountOfSubstance_ (this),
    luminousIntensity_ (this),
    currency_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Scalar::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // length
      //
      if (n.name () == "length" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->length_)
        {
          this->length_.set (length_traits::create (i, f, this));
          continue;
        }
      }

      // mass
      //
      if (n.name () == "mass" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->mass_)
        {
          this->mass_.set (mass_traits::create (i, f, this));
          continue;
        }
      }

      // time
      //
      if (n.name () == "time" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->time_)
        {
          this->time_.set (time_traits::create (i, f, this));
          continue;
        }
      }

      // electricCurrent
      //
      if (n.name () == "electricCurrent" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->electricCurrent_)
        {
          this->electricCurrent_.set (electricCurrent_traits::create (i, f, this));
          continue;
        }
      }

      // temperature
      //
      if (n.name () == "temperature" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->temperature_)
        {
          this->temperature_.set (temperature_traits::create (i, f, this));
          continue;
        }
      }

      // amountOfSubstance
      //
      if (n.name () == "amountOfSubstance" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->amountOfSubstance_)
        {
          this->amountOfSubstance_.set (amountOfSubstance_traits::create (i, f, this));
          continue;
        }
      }

      // luminousIntensity
      //
      if (n.name () == "luminousIntensity" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->luminousIntensity_)
        {
          this->luminousIntensity_.set (luminousIntensity_traits::create (i, f, this));
          continue;
        }
      }

      // currency
      //
      if (n.name () == "currency" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->currency_)
        {
          this->currency_.set (currency_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  Scalar* Scalar::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Scalar (*this, f, c);
  }

  Scalar& Scalar::
  operator= (const Scalar& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->length_ = x.length_;
      this->mass_ = x.mass_;
      this->time_ = x.time_;
      this->electricCurrent_ = x.electricCurrent_;
      this->temperature_ = x.temperature_;
      this->amountOfSubstance_ = x.amountOfSubstance_;
      this->luminousIntensity_ = x.luminousIntensity_;
      this->currency_ = x.currency_;
    }

    return *this;
  }

  Scalar::
  ~Scalar ()
  {
  }

  // DataType
  //

  DataType::
  DataType ()
  : ::xml_schema::type (),
    boolean_ (this),
    nominal_ (this),
    ordinal_ (this),
    scalar_ (this),
    directional_ (this),
    ldd_ (this)
  {
  }

  DataType::
  DataType (const DataType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_ (x.boolean_, f, this),
    nominal_ (x.nominal_, f, this),
    ordinal_ (x.ordinal_, f, this),
    scalar_ (x.scalar_, f, this),
    directional_ (x.directional_, f, this),
    ldd_ (x.ldd_, f, this)
  {
  }

  DataType::
  DataType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_ (this),
    nominal_ (this),
    ordinal_ (this),
    scalar_ (this),
    directional_ (this),
    ldd_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean
      //
      if (n.name () == "boolean" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< boolean_type > r (
          boolean_traits::create (i, f, this));

        if (!this->boolean_)
        {
          this->boolean_.set (::std::move (r));
          continue;
        }
      }

      // nominal
      //
      if (n.name () == "nominal" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< nominal_type > r (
          nominal_traits::create (i, f, this));

        if (!this->nominal_)
        {
          this->nominal_.set (::std::move (r));
          continue;
        }
      }

      // ordinal
      //
      if (n.name () == "ordinal" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< ordinal_type > r (
          ordinal_traits::create (i, f, this));

        if (!this->ordinal_)
        {
          this->ordinal_.set (::std::move (r));
          continue;
        }
      }

      // scalar
      //
      if (n.name () == "scalar" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< scalar_type > r (
          scalar_traits::create (i, f, this));

        if (!this->scalar_)
        {
          this->scalar_.set (::std::move (r));
          continue;
        }
      }

      // directional
      //
      if (n.name () == "directional" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< directional_type > r (
          directional_traits::create (i, f, this));

        if (!this->directional_)
        {
          this->directional_.set (::std::move (r));
          continue;
        }
      }

      // ldd
      //
      if (n.name () == "ldd" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< ldd_type > r (
          ldd_traits::create (i, f, this));

        if (!this->ldd_)
        {
          this->ldd_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DataType* DataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataType (*this, f, c);
  }

  DataType& DataType::
  operator= (const DataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->boolean_ = x.boolean_;
      this->nominal_ = x.nominal_;
      this->ordinal_ = x.ordinal_;
      this->scalar_ = x.scalar_;
      this->directional_ = x.directional_;
      this->ldd_ = x.ldd_;
    }

    return *this;
  }

  DataType::
  ~DataType ()
  {
  }

  // DataTypeOfValue
  //

  DataTypeOfValue::
  DataTypeOfValue ()
  : ::xml_schema::type (),
    boolean_ (this),
    ldd_ (this),
    nominal_ (this),
    ordinal_ (this),
    scalar_ (this),
    directional_ (this)
  {
  }

  DataTypeOfValue::
  DataTypeOfValue (const DataTypeOfValue& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_ (x.boolean_, f, this),
    ldd_ (x.ldd_, f, this),
    nominal_ (x.nominal_, f, this),
    ordinal_ (x.ordinal_, f, this),
    scalar_ (x.scalar_, f, this),
    directional_ (x.directional_, f, this)
  {
  }

  DataTypeOfValue::
  DataTypeOfValue (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_ (this),
    ldd_ (this),
    nominal_ (this),
    ordinal_ (this),
    scalar_ (this),
    directional_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataTypeOfValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean
      //
      if (n.name () == "boolean" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< boolean_type > r (
          boolean_traits::create (i, f, this));

        if (!this->boolean_)
        {
          this->boolean_.set (::std::move (r));
          continue;
        }
      }

      // ldd
      //
      if (n.name () == "ldd" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< ldd_type > r (
          ldd_traits::create (i, f, this));

        if (!this->ldd_)
        {
          this->ldd_.set (::std::move (r));
          continue;
        }
      }

      // nominal
      //
      if (n.name () == "nominal" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< nominal_type > r (
          nominal_traits::create (i, f, this));

        if (!this->nominal_)
        {
          this->nominal_.set (::std::move (r));
          continue;
        }
      }

      // ordinal
      //
      if (n.name () == "ordinal" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< ordinal_type > r (
          ordinal_traits::create (i, f, this));

        if (!this->ordinal_)
        {
          this->ordinal_.set (::std::move (r));
          continue;
        }
      }

      // scalar
      //
      if (n.name () == "scalar" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< scalar_type > r (
          scalar_traits::create (i, f, this));

        if (!this->scalar_)
        {
          this->scalar_.set (::std::move (r));
          continue;
        }
      }

      // directional
      //
      if (n.name () == "directional" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< directional_type > r (
          directional_traits::create (i, f, this));

        if (!this->directional_)
        {
          this->directional_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DataTypeOfValue* DataTypeOfValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataTypeOfValue (*this, f, c);
  }

  DataTypeOfValue& DataTypeOfValue::
  operator= (const DataTypeOfValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->boolean_ = x.boolean_;
      this->ldd_ = x.ldd_;
      this->nominal_ = x.nominal_;
      this->ordinal_ = x.ordinal_;
      this->scalar_ = x.scalar_;
      this->directional_ = x.directional_;
    }

    return *this;
  }

  DataTypeOfValue::
  ~DataTypeOfValue ()
  {
  }

  // CoordinateMask
  //

  CoordinateMask::
  CoordinateMask (const xMinimum_type& xMinimum,
                  const xMaximum_type& xMaximum,
                  const yMinimum_type& yMinimum,
                  const yMaximum_type& yMaximum)
  : ::xml_schema::type (),
    xMinimum_ (xMinimum, this),
    xMaximum_ (xMaximum, this),
    yMinimum_ (yMinimum, this),
    yMaximum_ (yMaximum, this)
  {
  }

  CoordinateMask::
  CoordinateMask (const CoordinateMask& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xMinimum_ (x.xMinimum_, f, this),
    xMaximum_ (x.xMaximum_, f, this),
    yMinimum_ (x.yMinimum_, f, this),
    yMaximum_ (x.yMaximum_, f, this)
  {
  }

  CoordinateMask::
  CoordinateMask (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xMinimum_ (this),
    xMaximum_ (this),
    yMinimum_ (this),
    yMaximum_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CoordinateMask::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // xMinimum
      //
      if (n.name () == "xMinimum" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!xMinimum_.present ())
        {
          this->xMinimum_.set (xMinimum_traits::create (i, f, this));
          continue;
        }
      }

      // xMaximum
      //
      if (n.name () == "xMaximum" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!xMaximum_.present ())
        {
          this->xMaximum_.set (xMaximum_traits::create (i, f, this));
          continue;
        }
      }

      // yMinimum
      //
      if (n.name () == "yMinimum" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!yMinimum_.present ())
        {
          this->yMinimum_.set (yMinimum_traits::create (i, f, this));
          continue;
        }
      }

      // yMaximum
      //
      if (n.name () == "yMaximum" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!yMaximum_.present ())
        {
          this->yMaximum_.set (yMaximum_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!xMinimum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "xMinimum",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!xMaximum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "xMaximum",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!yMinimum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "yMinimum",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!yMaximum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "yMaximum",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  CoordinateMask* CoordinateMask::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CoordinateMask (*this, f, c);
  }

  CoordinateMask& CoordinateMask::
  operator= (const CoordinateMask& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->xMinimum_ = x.xMinimum_;
      this->xMaximum_ = x.xMaximum_;
      this->yMinimum_ = x.yMinimum_;
      this->yMaximum_ = x.yMaximum_;
    }

    return *this;
  }

  CoordinateMask::
  ~CoordinateMask ()
  {
  }

  // AreaMap
  //

  AreaMap::
  AreaMap (const nrRows_type& nrRows,
           const nrCols_type& nrCols)
  : ::xml_schema::type (),
    nrRows_ (nrRows, this),
    nrCols_ (nrCols, this),
    cellSize_ (this),
    xLowerLeftCorner_ (this),
    yLowerLeftCorner_ (this)
  {
  }

  AreaMap::
  AreaMap (const AreaMap& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    nrRows_ (x.nrRows_, f, this),
    nrCols_ (x.nrCols_, f, this),
    cellSize_ (x.cellSize_, f, this),
    xLowerLeftCorner_ (x.xLowerLeftCorner_, f, this),
    yLowerLeftCorner_ (x.yLowerLeftCorner_, f, this)
  {
  }

  AreaMap::
  AreaMap (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    nrRows_ (this),
    nrCols_ (this),
    cellSize_ (this),
    xLowerLeftCorner_ (this),
    yLowerLeftCorner_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AreaMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nrRows
      //
      if (n.name () == "nrRows" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< nrRows_type > r (
          nrRows_traits::create (i, f, this));

        if (!nrRows_.present ())
        {
          this->nrRows_.set (::std::move (r));
          continue;
        }
      }

      // nrCols
      //
      if (n.name () == "nrCols" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< nrCols_type > r (
          nrCols_traits::create (i, f, this));

        if (!nrCols_.present ())
        {
          this->nrCols_.set (::std::move (r));
          continue;
        }
      }

      // cellSize
      //
      if (n.name () == "cellSize" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->cellSize_)
        {
          this->cellSize_.set (cellSize_traits::create (i, f, this));
          continue;
        }
      }

      // xLowerLeftCorner
      //
      if (n.name () == "xLowerLeftCorner" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->xLowerLeftCorner_)
        {
          this->xLowerLeftCorner_.set (xLowerLeftCorner_traits::create (i, f, this));
          continue;
        }
      }

      // yLowerLeftCorner
      //
      if (n.name () == "yLowerLeftCorner" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->yLowerLeftCorner_)
        {
          this->yLowerLeftCorner_.set (yLowerLeftCorner_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!nrRows_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nrRows",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!nrCols_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nrCols",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  AreaMap* AreaMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AreaMap (*this, f, c);
  }

  AreaMap& AreaMap::
  operator= (const AreaMap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->nrRows_ = x.nrRows_;
      this->nrCols_ = x.nrCols_;
      this->cellSize_ = x.cellSize_;
      this->xLowerLeftCorner_ = x.xLowerLeftCorner_;
      this->yLowerLeftCorner_ = x.yLowerLeftCorner_;
    }

    return *this;
  }

  AreaMap::
  ~AreaMap ()
  {
  }

  // FieldReference
  //

  FieldReference::
  FieldReference (const ref_type& ref)
  : ::xml_schema::type (),
    ref_ (ref, this)
  {
  }

  FieldReference::
  FieldReference (const FieldReference& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  FieldReference::
  FieldReference (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FieldReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        this->ref_.set (ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  FieldReference* FieldReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FieldReference (*this, f, c);
  }

  FieldReference& FieldReference::
  operator= (const FieldReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ref_ = x.ref_;
    }

    return *this;
  }

  FieldReference::
  ~FieldReference ()
  {
  }

  // AreaMapScript
  //

  AreaMapScript::
  AreaMapScript ()
  : ::xml_schema::type (),
    fieldReference_ (this),
    nrRows_ (this),
    nrCols_ (this),
    cellSize_ (this),
    xLowerLeftCorner_ (this),
    yLowerLeftCorner_ (this)
  {
  }

  AreaMapScript::
  AreaMapScript (const AreaMapScript& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fieldReference_ (x.fieldReference_, f, this),
    nrRows_ (x.nrRows_, f, this),
    nrCols_ (x.nrCols_, f, this),
    cellSize_ (x.cellSize_, f, this),
    xLowerLeftCorner_ (x.xLowerLeftCorner_, f, this),
    yLowerLeftCorner_ (x.yLowerLeftCorner_, f, this)
  {
  }

  AreaMapScript::
  AreaMapScript (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fieldReference_ (this),
    nrRows_ (this),
    nrCols_ (this),
    cellSize_ (this),
    xLowerLeftCorner_ (this),
    yLowerLeftCorner_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AreaMapScript::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // fieldReference
      //
      if (n.name () == "fieldReference" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< fieldReference_type > r (
          fieldReference_traits::create (i, f, this));

        if (!this->fieldReference_)
        {
          this->fieldReference_.set (::std::move (r));
          continue;
        }
      }

      // nrRows
      //
      if (n.name () == "nrRows" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< nrRows_type > r (
          nrRows_traits::create (i, f, this));

        if (!this->nrRows_)
        {
          this->nrRows_.set (::std::move (r));
          continue;
        }
      }

      // nrCols
      //
      if (n.name () == "nrCols" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< nrCols_type > r (
          nrCols_traits::create (i, f, this));

        if (!this->nrCols_)
        {
          this->nrCols_.set (::std::move (r));
          continue;
        }
      }

      // cellSize
      //
      if (n.name () == "cellSize" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->cellSize_)
        {
          this->cellSize_.set (cellSize_traits::create (i, f, this));
          continue;
        }
      }

      // xLowerLeftCorner
      //
      if (n.name () == "xLowerLeftCorner" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->xLowerLeftCorner_)
        {
          this->xLowerLeftCorner_.set (xLowerLeftCorner_traits::create (i, f, this));
          continue;
        }
      }

      // yLowerLeftCorner
      //
      if (n.name () == "yLowerLeftCorner" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->yLowerLeftCorner_)
        {
          this->yLowerLeftCorner_.set (yLowerLeftCorner_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  AreaMapScript* AreaMapScript::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AreaMapScript (*this, f, c);
  }

  AreaMapScript& AreaMapScript::
  operator= (const AreaMapScript& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fieldReference_ = x.fieldReference_;
      this->nrRows_ = x.nrRows_;
      this->nrCols_ = x.nrCols_;
      this->cellSize_ = x.cellSize_;
      this->xLowerLeftCorner_ = x.xLowerLeftCorner_;
      this->yLowerLeftCorner_ = x.yLowerLeftCorner_;
    }

    return *this;
  }

  AreaMapScript::
  ~AreaMapScript ()
  {
  }

  // MaskMapType
  //

  MaskMapType::
  MaskMapType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_MaskMapType_convert ();
  }

  MaskMapType::
  MaskMapType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_MaskMapType_convert ();
  }

  MaskMapType::
  MaskMapType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_MaskMapType_convert ();
  }

  MaskMapType* MaskMapType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MaskMapType (*this, f, c);
  }

  MaskMapType::value MaskMapType::
  _xsd_MaskMapType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MaskMapType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_MaskMapType_indexes_,
                      _xsd_MaskMapType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_MaskMapType_indexes_ + 2 || _xsd_MaskMapType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MaskMapType::
  _xsd_MaskMapType_literals_[2] =
  {
    "computeAtNonMissingValues",
    "computeAtNonZeroValues"
  };

  const MaskMapType::value MaskMapType::
  _xsd_MaskMapType_indexes_[2] =
  {
    ::pcrxml::MaskMapType::computeAtNonMissingValues,
    ::pcrxml::MaskMapType::computeAtNonZeroValues
  };

  // ComputationMaskByAreaMap
  //

  ComputationMaskByAreaMap::
  ComputationMaskByAreaMap (const maskType_type& maskType)
  : ::xml_schema::type (),
    maskType_ (maskType, this)
  {
  }

  ComputationMaskByAreaMap::
  ComputationMaskByAreaMap (const ComputationMaskByAreaMap& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    maskType_ (x.maskType_, f, this)
  {
  }

  ComputationMaskByAreaMap::
  ComputationMaskByAreaMap (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    maskType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ComputationMaskByAreaMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "maskType" && n.namespace_ ().empty ())
      {
        this->maskType_.set (maskType_traits::create (i, f, this));
        continue;
      }
    }

    if (!maskType_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maskType",
        "");
    }
  }

  ComputationMaskByAreaMap* ComputationMaskByAreaMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComputationMaskByAreaMap (*this, f, c);
  }

  ComputationMaskByAreaMap& ComputationMaskByAreaMap::
  operator= (const ComputationMaskByAreaMap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->maskType_ = x.maskType_;
    }

    return *this;
  }

  ComputationMaskByAreaMap::
  ~ComputationMaskByAreaMap ()
  {
  }

  // ComputationMask
  //

  ComputationMask::
  ComputationMask ()
  : ::xml_schema::type (),
    areaMap_ (this),
    coordinates_ (this)
  {
  }

  ComputationMask::
  ComputationMask (const ComputationMask& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    areaMap_ (x.areaMap_, f, this),
    coordinates_ (x.coordinates_, f, this)
  {
  }

  ComputationMask::
  ComputationMask (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    areaMap_ (this),
    coordinates_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ComputationMask::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // areaMap
      //
      if (n.name () == "areaMap" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< areaMap_type > r (
          areaMap_traits::create (i, f, this));

        if (!this->areaMap_)
        {
          this->areaMap_.set (::std::move (r));
          continue;
        }
      }

      // coordinates
      //
      if (n.name () == "coordinates" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< coordinates_type > r (
          coordinates_traits::create (i, f, this));

        if (!this->coordinates_)
        {
          this->coordinates_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ComputationMask* ComputationMask::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComputationMask (*this, f, c);
  }

  ComputationMask& ComputationMask::
  operator= (const ComputationMask& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->areaMap_ = x.areaMap_;
      this->coordinates_ = x.coordinates_;
    }

    return *this;
  }

  ComputationMask::
  ~ComputationMask ()
  {
  }

  // TimerOfModel
  //

  TimerOfModel::
  TimerOfModel (const integer_type& integer)
  : ::xml_schema::type (),
    integer_ (integer, this)
  {
  }

  TimerOfModel::
  TimerOfModel (::std::unique_ptr< integer_type > integer)
  : ::xml_schema::type (),
    integer_ (std::move (integer), this)
  {
  }

  TimerOfModel::
  TimerOfModel (const TimerOfModel& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_ (x.integer_, f, this)
  {
  }

  TimerOfModel::
  TimerOfModel (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TimerOfModel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer
      //
      if (n.name () == "integer" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< integer_type > r (
          integer_traits::create (i, f, this));

        if (!integer_.present ())
        {
          this->integer_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!integer_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "integer",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  TimerOfModel* TimerOfModel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimerOfModel (*this, f, c);
  }

  TimerOfModel& TimerOfModel::
  operator= (const TimerOfModel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->integer_ = x.integer_;
    }

    return *this;
  }

  TimerOfModel::
  ~TimerOfModel ()
  {
  }

  // IntegerTimer
  //

  IntegerTimer::
  IntegerTimer (const start_type& start)
  : ::xml_schema::type (),
    start_ (start, this),
    end_ (this)
  {
  }

  IntegerTimer::
  IntegerTimer (const IntegerTimer& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this)
  {
  }

  IntegerTimer::
  IntegerTimer (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    start_ (this),
    end_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void IntegerTimer::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // start
      //
      if (n.name () == "start" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< start_type > r (
          start_traits::create (i, f, this));

        if (!start_.present ())
        {
          this->start_.set (::std::move (r));
          continue;
        }
      }

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< end_type > r (
          end_traits::create (i, f, this));

        if (!this->end_)
        {
          this->end_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!start_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "start",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  IntegerTimer* IntegerTimer::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IntegerTimer (*this, f, c);
  }

  IntegerTimer& IntegerTimer::
  operator= (const IntegerTimer& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->start_ = x.start_;
      this->end_ = x.end_;
    }

    return *this;
  }

  IntegerTimer::
  ~IntegerTimer ()
  {
  }

  // TimerContext
  //

  TimerContext::
  TimerContext (const current_type& current)
  : ::xml_schema::type (),
    current_ (current, this),
    start_ (this),
    end_ (this)
  {
  }

  TimerContext::
  TimerContext (const TimerContext& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    current_ (x.current_, f, this),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this)
  {
  }

  TimerContext::
  TimerContext (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    current_ (this),
    start_ (this),
    end_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TimerContext::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // current
      //
      if (n.name () == "current" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!current_.present ())
        {
          this->current_.set (current_traits::create (i, f, this));
          continue;
        }
      }

      // start
      //
      if (n.name () == "start" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->start_)
        {
          this->start_.set (start_traits::create (i, f, this));
          continue;
        }
      }

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        if (!this->end_)
        {
          this->end_.set (end_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!current_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "current",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  TimerContext* TimerContext::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimerContext (*this, f, c);
  }

  TimerContext& TimerContext::
  operator= (const TimerContext& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->current_ = x.current_;
      this->start_ = x.start_;
      this->end_ = x.end_;
    }

    return *this;
  }

  TimerContext::
  ~TimerContext ()
  {
  }

  // CheckContext
  //

  CheckContext::
  CheckContext ()
  : ::xml_schema::type (),
    areaMap_ (this),
    computationMask_ (this),
    timer_ (this)
  {
  }

  CheckContext::
  CheckContext (const CheckContext& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    areaMap_ (x.areaMap_, f, this),
    computationMask_ (x.computationMask_, f, this),
    timer_ (x.timer_, f, this)
  {
  }

  CheckContext::
  CheckContext (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    areaMap_ (this),
    computationMask_ (this),
    timer_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CheckContext::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // areaMap
      //
      if (n.name () == "areaMap" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< areaMap_type > r (
          areaMap_traits::create (i, f, this));

        if (!this->areaMap_)
        {
          this->areaMap_.set (::std::move (r));
          continue;
        }
      }

      // computationMask
      //
      if (n.name () == "computationMask" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< computationMask_type > r (
          computationMask_traits::create (i, f, this));

        if (!this->computationMask_)
        {
          this->computationMask_.set (::std::move (r));
          continue;
        }
      }

      // timer
      //
      if (n.name () == "timer" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< timer_type > r (
          timer_traits::create (i, f, this));

        if (!this->timer_)
        {
          this->timer_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CheckContext* CheckContext::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CheckContext (*this, f, c);
  }

  CheckContext& CheckContext::
  operator= (const CheckContext& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->areaMap_ = x.areaMap_;
      this->computationMask_ = x.computationMask_;
      this->timer_ = x.timer_;
    }

    return *this;
  }

  CheckContext::
  ~CheckContext ()
  {
  }

  // RunContext
  //

  RunContext::
  RunContext (const areaMap_type& areaMap,
              const timer_type& timer)
  : ::xml_schema::type (),
    areaMap_ (areaMap, this),
    computationMask_ (this),
    timer_ (timer, this)
  {
  }

  RunContext::
  RunContext (::std::unique_ptr< areaMap_type > areaMap,
              ::std::unique_ptr< timer_type > timer)
  : ::xml_schema::type (),
    areaMap_ (std::move (areaMap), this),
    computationMask_ (this),
    timer_ (std::move (timer), this)
  {
  }

  RunContext::
  RunContext (const RunContext& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    areaMap_ (x.areaMap_, f, this),
    computationMask_ (x.computationMask_, f, this),
    timer_ (x.timer_, f, this)
  {
  }

  RunContext::
  RunContext (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    areaMap_ (this),
    computationMask_ (this),
    timer_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RunContext::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // areaMap
      //
      if (n.name () == "areaMap" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< areaMap_type > r (
          areaMap_traits::create (i, f, this));

        if (!areaMap_.present ())
        {
          this->areaMap_.set (::std::move (r));
          continue;
        }
      }

      // computationMask
      //
      if (n.name () == "computationMask" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< computationMask_type > r (
          computationMask_traits::create (i, f, this));

        if (!this->computationMask_)
        {
          this->computationMask_.set (::std::move (r));
          continue;
        }
      }

      // timer
      //
      if (n.name () == "timer" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< timer_type > r (
          timer_traits::create (i, f, this));

        if (!timer_.present ())
        {
          this->timer_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!areaMap_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "areaMap",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!timer_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timer",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  RunContext* RunContext::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RunContext (*this, f, c);
  }

  RunContext& RunContext::
  operator= (const RunContext& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->areaMap_ = x.areaMap_;
      this->computationMask_ = x.computationMask_;
      this->timer_ = x.timer_;
    }

    return *this;
  }

  RunContext::
  ~RunContext ()
  {
  }

  // LinkInLibraryManifest
  //

  LinkInLibraryManifest::
  LinkInLibraryManifest ()
  : ::xml_schema::type (),
    function_ (this),
    class__ (this)
  {
  }

  LinkInLibraryManifest::
  LinkInLibraryManifest (const LinkInLibraryManifest& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    function_ (x.function_, f, this),
    class__ (x.class__, f, this)
  {
  }

  LinkInLibraryManifest::
  LinkInLibraryManifest (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    function_ (this),
    class__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInLibraryManifest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // function
      //
      if (n.name () == "function" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< function_type > r (
          function_traits::create (i, f, this));

        this->function_.push_back (::std::move (r));
        continue;
      }

      // class
      //
      if (n.name () == "class" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< class_type > r (
          class_traits::create (i, f, this));

        this->class__.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LinkInLibraryManifest* LinkInLibraryManifest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInLibraryManifest (*this, f, c);
  }

  LinkInLibraryManifest& LinkInLibraryManifest::
  operator= (const LinkInLibraryManifest& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->function_ = x.function_;
      this->class__ = x.class__;
    }

    return *this;
  }

  LinkInLibraryManifest::
  ~LinkInLibraryManifest ()
  {
  }

  // LinkInClassManifest
  //

  LinkInClassManifest::
  LinkInClassManifest (const name_type& name,
                       const constructor_type& constructor)
  : ::xml_schema::type (),
    name_ (name, this),
    constructor_ (constructor, this),
    method_ (this)
  {
  }

  LinkInClassManifest::
  LinkInClassManifest (const name_type& name,
                       ::std::unique_ptr< constructor_type > constructor)
  : ::xml_schema::type (),
    name_ (name, this),
    constructor_ (std::move (constructor), this),
    method_ (this)
  {
  }

  LinkInClassManifest::
  LinkInClassManifest (const LinkInClassManifest& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    constructor_ (x.constructor_, f, this),
    method_ (x.method_, f, this)
  {
  }

  LinkInClassManifest::
  LinkInClassManifest (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    constructor_ (this),
    method_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInClassManifest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // constructor
      //
      if (n.name () == "constructor" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< constructor_type > r (
          constructor_traits::create (i, f, this));

        if (!constructor_.present ())
        {
          this->constructor_.set (::std::move (r));
          continue;
        }
      }

      // method
      //
      if (n.name () == "method" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< method_type > r (
          method_traits::create (i, f, this));

        this->method_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!constructor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "constructor",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  LinkInClassManifest* LinkInClassManifest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInClassManifest (*this, f, c);
  }

  LinkInClassManifest& LinkInClassManifest::
  operator= (const LinkInClassManifest& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->constructor_ = x.constructor_;
      this->method_ = x.method_;
    }

    return *this;
  }

  LinkInClassManifest::
  ~LinkInClassManifest ()
  {
  }

  // LinkInClassConstructor
  //

  LinkInClassConstructor::
  LinkInClassConstructor ()
  : ::xml_schema::type (),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInClassConstructor::
  LinkInClassConstructor (const LinkInClassConstructor& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    stringArgument_ (x.stringArgument_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  LinkInClassConstructor::
  LinkInClassConstructor (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    stringArgument_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInClassConstructor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stringArgument
      //
      if (n.name () == "stringArgument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< stringArgument_type > r (
          stringArgument_traits::create (i, f, this));

        if (!this->stringArgument_)
        {
          this->stringArgument_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LinkInClassConstructor* LinkInClassConstructor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInClassConstructor (*this, f, c);
  }

  LinkInClassConstructor& LinkInClassConstructor::
  operator= (const LinkInClassConstructor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->stringArgument_ = x.stringArgument_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  LinkInClassConstructor::
  ~LinkInClassConstructor ()
  {
  }

  // FieldType
  //

  FieldType::
  FieldType (const dataType_type& dataType,
             const spatialType_type& spatialType)
  : ::xml_schema::type (),
    dataType_ (dataType, this),
    spatialType_ (spatialType, this)
  {
  }

  FieldType::
  FieldType (::std::unique_ptr< dataType_type > dataType,
             const spatialType_type& spatialType)
  : ::xml_schema::type (),
    dataType_ (std::move (dataType), this),
    spatialType_ (spatialType, this)
  {
  }

  FieldType::
  FieldType (const FieldType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    spatialType_ (x.spatialType_, f, this)
  {
  }

  FieldType::
  FieldType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    spatialType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FieldType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        if (!dataType_.present ())
        {
          this->dataType_.set (::std::move (r));
          continue;
        }
      }

      // spatialType
      //
      if (n.name () == "spatialType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< spatialType_type > r (
          spatialType_traits::create (i, f, this));

        if (!spatialType_.present ())
        {
          this->spatialType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!dataType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dataType",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!spatialType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spatialType",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  FieldType* FieldType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FieldType (*this, f, c);
  }

  FieldType& FieldType::
  operator= (const FieldType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->spatialType_ = x.spatialType_;
    }

    return *this;
  }

  FieldType::
  ~FieldType ()
  {
  }

  // FieldTypeOfValue
  //

  FieldTypeOfValue::
  FieldTypeOfValue (const dataType_type& dataType,
                    const spatialType_type& spatialType)
  : ::xml_schema::type (),
    dataType_ (dataType, this),
    spatialType_ (spatialType, this)
  {
  }

  FieldTypeOfValue::
  FieldTypeOfValue (::std::unique_ptr< dataType_type > dataType,
                    const spatialType_type& spatialType)
  : ::xml_schema::type (),
    dataType_ (std::move (dataType), this),
    spatialType_ (spatialType, this)
  {
  }

  FieldTypeOfValue::
  FieldTypeOfValue (const FieldTypeOfValue& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    spatialType_ (x.spatialType_, f, this)
  {
  }

  FieldTypeOfValue::
  FieldTypeOfValue (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    spatialType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FieldTypeOfValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        if (!dataType_.present ())
        {
          this->dataType_.set (::std::move (r));
          continue;
        }
      }

      // spatialType
      //
      if (n.name () == "spatialType" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< spatialType_type > r (
          spatialType_traits::create (i, f, this));

        if (!spatialType_.present ())
        {
          this->spatialType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!dataType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dataType",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!spatialType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spatialType",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  FieldTypeOfValue* FieldTypeOfValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FieldTypeOfValue (*this, f, c);
  }

  FieldTypeOfValue& FieldTypeOfValue::
  operator= (const FieldTypeOfValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->spatialType_ = x.spatialType_;
    }

    return *this;
  }

  FieldTypeOfValue::
  ~FieldTypeOfValue ()
  {
  }

  // LinkInClassMethod
  //

  LinkInClassMethod::
  LinkInClassMethod (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInClassMethod::
  LinkInClassMethod (const LinkInClassMethod& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    result_ (x.result_, f, this),
    stringArgument_ (x.stringArgument_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  LinkInClassMethod::
  LinkInClassMethod (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInClassMethod::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< result_type > r (
          result_traits::create (i, f, this));

        this->result_.push_back (::std::move (r));
        continue;
      }

      // stringArgument
      //
      if (n.name () == "stringArgument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< stringArgument_type > r (
          stringArgument_traits::create (i, f, this));

        if (!this->stringArgument_)
        {
          this->stringArgument_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  LinkInClassMethod* LinkInClassMethod::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInClassMethod (*this, f, c);
  }

  LinkInClassMethod& LinkInClassMethod::
  operator= (const LinkInClassMethod& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->result_ = x.result_;
      this->stringArgument_ = x.stringArgument_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  LinkInClassMethod::
  ~LinkInClassMethod ()
  {
  }

  // LinkInFunctionManifest
  //

  LinkInFunctionManifest::
  LinkInFunctionManifest (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInFunctionManifest::
  LinkInFunctionManifest (const LinkInFunctionManifest& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    result_ (x.result_, f, this),
    stringArgument_ (x.stringArgument_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  LinkInFunctionManifest::
  LinkInFunctionManifest (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInFunctionManifest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< result_type > r (
          result_traits::create (i, f, this));

        this->result_.push_back (::std::move (r));
        continue;
      }

      // stringArgument
      //
      if (n.name () == "stringArgument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< stringArgument_type > r (
          stringArgument_traits::create (i, f, this));

        if (!this->stringArgument_)
        {
          this->stringArgument_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  LinkInFunctionManifest* LinkInFunctionManifest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInFunctionManifest (*this, f, c);
  }

  LinkInFunctionManifest& LinkInFunctionManifest::
  operator= (const LinkInFunctionManifest& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->result_ = x.result_;
      this->stringArgument_ = x.stringArgument_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  LinkInFunctionManifest::
  ~LinkInFunctionManifest ()
  {
  }

  // CallPoint
  //

  CallPoint::
  CallPoint ()
  : ::xml_schema::type (),
    object_ (this),
    function_ (this)
  {
  }

  CallPoint::
  CallPoint (const CallPoint& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    object_ (x.object_, f, this),
    function_ (x.function_, f, this)
  {
  }

  CallPoint::
  CallPoint (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    object_ (this),
    function_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CallPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // object
      //
      if (n.name () == "object" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< object_type > r (
          object_traits::create (i, f, this));

        if (!this->object_)
        {
          this->object_.set (::std::move (r));
          continue;
        }
      }

      // function
      //
      if (n.name () == "function" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< function_type > r (
          function_traits::create (i, f, this));

        if (!this->function_)
        {
          this->function_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CallPoint* CallPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CallPoint (*this, f, c);
  }

  CallPoint& CallPoint::
  operator= (const CallPoint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->object_ = x.object_;
      this->function_ = x.function_;
    }

    return *this;
  }

  CallPoint::
  ~CallPoint ()
  {
  }

  // LinkInCheckInput
  //

  LinkInCheckInput::
  LinkInCheckInput (const context_type& context,
                    const callPoint_type& callPoint)
  : ::xml_schema::type (),
    context_ (context, this),
    callPoint_ (callPoint, this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInCheckInput::
  LinkInCheckInput (::std::unique_ptr< context_type > context,
                    ::std::unique_ptr< callPoint_type > callPoint)
  : ::xml_schema::type (),
    context_ (std::move (context), this),
    callPoint_ (std::move (callPoint), this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInCheckInput::
  LinkInCheckInput (const LinkInCheckInput& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    context_ (x.context_, f, this),
    callPoint_ (x.callPoint_, f, this),
    result_ (x.result_, f, this),
    stringArgument_ (x.stringArgument_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  LinkInCheckInput::
  LinkInCheckInput (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    context_ (this),
    callPoint_ (this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInCheckInput::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // context
      //
      if (n.name () == "context" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< context_type > r (
          context_traits::create (i, f, this));

        if (!context_.present ())
        {
          this->context_.set (::std::move (r));
          continue;
        }
      }

      // callPoint
      //
      if (n.name () == "callPoint" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< callPoint_type > r (
          callPoint_traits::create (i, f, this));

        if (!callPoint_.present ())
        {
          this->callPoint_.set (::std::move (r));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< result_type > r (
          result_traits::create (i, f, this));

        this->result_.push_back (::std::move (r));
        continue;
      }

      // stringArgument
      //
      if (n.name () == "stringArgument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< stringArgument_type > r (
          stringArgument_traits::create (i, f, this));

        if (!this->stringArgument_)
        {
          this->stringArgument_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!context_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "context",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!callPoint_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "callPoint",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  LinkInCheckInput* LinkInCheckInput::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInCheckInput (*this, f, c);
  }

  LinkInCheckInput& LinkInCheckInput::
  operator= (const LinkInCheckInput& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->context_ = x.context_;
      this->callPoint_ = x.callPoint_;
      this->result_ = x.result_;
      this->stringArgument_ = x.stringArgument_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  LinkInCheckInput::
  ~LinkInCheckInput ()
  {
  }

  // LinkInCheckResult
  //

  LinkInCheckResult::
  LinkInCheckResult ()
  : ::xml_schema::type (),
    error_ (this),
    result_ (this),
    argument_ (this)
  {
  }

  LinkInCheckResult::
  LinkInCheckResult (const LinkInCheckResult& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    error_ (x.error_, f, this),
    result_ (x.result_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  LinkInCheckResult::
  LinkInCheckResult (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    error_ (this),
    result_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInCheckResult::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< error_type > r (
          error_traits::create (i, f, this));

        if (!this->error_)
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< result_type > r (
          result_traits::create (i, f, this));

        this->result_.push_back (::std::move (r));
        continue;
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LinkInCheckResult* LinkInCheckResult::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInCheckResult (*this, f, c);
  }

  LinkInCheckResult& LinkInCheckResult::
  operator= (const LinkInCheckResult& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->error_ = x.error_;
      this->result_ = x.result_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  LinkInCheckResult::
  ~LinkInCheckResult ()
  {
  }

  // LinkInExecuteInput
  //

  LinkInExecuteInput::
  LinkInExecuteInput (const context_type& context,
                      const callPoint_type& callPoint)
  : ::xml_schema::type (),
    context_ (context, this),
    callPoint_ (callPoint, this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInExecuteInput::
  LinkInExecuteInput (::std::unique_ptr< context_type > context,
                      ::std::unique_ptr< callPoint_type > callPoint)
  : ::xml_schema::type (),
    context_ (std::move (context), this),
    callPoint_ (std::move (callPoint), this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
  }

  LinkInExecuteInput::
  LinkInExecuteInput (const LinkInExecuteInput& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    context_ (x.context_, f, this),
    callPoint_ (x.callPoint_, f, this),
    result_ (x.result_, f, this),
    stringArgument_ (x.stringArgument_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  LinkInExecuteInput::
  LinkInExecuteInput (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    context_ (this),
    callPoint_ (this),
    result_ (this),
    stringArgument_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInExecuteInput::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // context
      //
      if (n.name () == "context" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< context_type > r (
          context_traits::create (i, f, this));

        if (!context_.present ())
        {
          this->context_.set (::std::move (r));
          continue;
        }
      }

      // callPoint
      //
      if (n.name () == "callPoint" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< callPoint_type > r (
          callPoint_traits::create (i, f, this));

        if (!callPoint_.present ())
        {
          this->callPoint_.set (::std::move (r));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< result_type > r (
          result_traits::create (i, f, this));

        this->result_.push_back (::std::move (r));
        continue;
      }

      // stringArgument
      //
      if (n.name () == "stringArgument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< stringArgument_type > r (
          stringArgument_traits::create (i, f, this));

        if (!this->stringArgument_)
        {
          this->stringArgument_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!context_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "context",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!callPoint_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "callPoint",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  LinkInExecuteInput* LinkInExecuteInput::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInExecuteInput (*this, f, c);
  }

  LinkInExecuteInput& LinkInExecuteInput::
  operator= (const LinkInExecuteInput& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->context_ = x.context_;
      this->callPoint_ = x.callPoint_;
      this->result_ = x.result_;
      this->stringArgument_ = x.stringArgument_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  LinkInExecuteInput::
  ~LinkInExecuteInput ()
  {
  }

  // LinkInExecuteResult
  //

  LinkInExecuteResult::
  LinkInExecuteResult ()
  : ::xml_schema::type (),
    error_ (this)
  {
  }

  LinkInExecuteResult::
  LinkInExecuteResult (const LinkInExecuteResult& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    error_ (x.error_, f, this)
  {
  }

  LinkInExecuteResult::
  LinkInExecuteResult (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    error_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LinkInExecuteResult::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< error_type > r (
          error_traits::create (i, f, this));

        if (!this->error_)
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LinkInExecuteResult* LinkInExecuteResult::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LinkInExecuteResult (*this, f, c);
  }

  LinkInExecuteResult& LinkInExecuteResult::
  operator= (const LinkInExecuteResult& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->error_ = x.error_;
    }

    return *this;
  }

  LinkInExecuteResult::
  ~LinkInExecuteResult ()
  {
  }

  // object
  //

  object::
  object (const className_type& className,
          const objectName_type& objectName)
  : ::xml_schema::type (),
    className_ (className, this),
    objectName_ (objectName, this),
    constructor_ (this),
    methodName_ (this)
  {
  }

  object::
  object (const object& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    className_ (x.className_, f, this),
    objectName_ (x.objectName_, f, this),
    constructor_ (x.constructor_, f, this),
    methodName_ (x.methodName_, f, this)
  {
  }

  object::
  object (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    className_ (this),
    objectName_ (this),
    constructor_ (this),
    methodName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void object::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // className
      //
      if (n.name () == "className" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< className_type > r (
          className_traits::create (i, f, this));

        if (!className_.present ())
        {
          this->className_.set (::std::move (r));
          continue;
        }
      }

      // objectName
      //
      if (n.name () == "objectName" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< objectName_type > r (
          objectName_traits::create (i, f, this));

        if (!objectName_.present ())
        {
          this->objectName_.set (::std::move (r));
          continue;
        }
      }

      // constructor
      //
      if (n.name () == "constructor" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< constructor_type > r (
          constructor_traits::create (i, f, this));

        if (!this->constructor_)
        {
          this->constructor_.set (::std::move (r));
          continue;
        }
      }

      // methodName
      //
      if (n.name () == "methodName" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< methodName_type > r (
          methodName_traits::create (i, f, this));

        if (!this->methodName_)
        {
          this->methodName_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!className_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "className",
        "http://www.pcraster.nl/pcrxml");
    }

    if (!objectName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectName",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  object* object::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class object (*this, f, c);
  }

  object& object::
  operator= (const object& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->className_ = x.className_;
      this->objectName_ = x.objectName_;
      this->constructor_ = x.constructor_;
      this->methodName_ = x.methodName_;
    }

    return *this;
  }

  object::
  ~object ()
  {
  }

  // function
  //

  function::
  function (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, this)
  {
  }

  function::
  function (const function& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this)
  {
  }

  function::
  function (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void function::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.pcraster.nl/pcrxml")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  function* function::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class function (*this, f, c);
  }

  function& function::
  operator= (const function& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
    }

    return *this;
  }

  function::
  ~function ()
  {
  }
}

#include <ostream>

namespace pcrxml
{
  ::std::ostream&
  operator<< (::std::ostream& o, SpatialType::value i)
  {
    return o << SpatialType::_xsd_SpatialType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpatialType& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SpatialTypeOfValue& i)
  {
    return o << static_cast< const ::pcrxml::SpatialType& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MemoryExchange& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Exchange& i)
  {
    if (i.external ())
    {
      o << ::std::endl << "external: " << *i.external ();
    }

    if (i.memoryExchange ())
    {
      o << ::std::endl << "memoryExchange: " << *i.memoryExchange ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Description& i)
  {
    o << ::std::endl << "text: " << i.text ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, ModelInputType::value i)
  {
    return o << ModelInputType::_xsd_ModelInputType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ModelInputType& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, ModelOutputType::value i)
  {
    return o << ModelOutputType::_xsd_ModelOutputType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ModelOutputType& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ModelExchange& i)
  {
    if (i.input ())
    {
      o << ::std::endl << "input: " << *i.input ();
    }

    if (i.output ())
    {
      o << ::std::endl << "output: " << *i.output ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LookupColumn& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const OutputMapFormat& i)
  {
    if (i.pcrasterMapFormat ())
    {
      o << ::std::endl << "pcrasterMapFormat: " << *i.pcrasterMapFormat ();
    }

    if (i.bandMapFormat ())
    {
      o << ::std::endl << "bandMapFormat: " << *i.bandMapFormat ();
    }

    if (i.esriGridFormat ())
    {
      o << ::std::endl << "esriGridFormat: " << *i.esriGridFormat ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, CellCoordinate::value i)
  {
    return o << CellCoordinate::_xsd_CellCoordinate_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CellCoordinate& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, DirectionalValueUnit::value i)
  {
    return o << DirectionalValueUnit::_xsd_DirectionalValueUnit_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DirectionalValueUnit& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, LddCreateDemMethod::value i)
  {
    return o << LddCreateDemMethod::_xsd_LddCreateDemMethod_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LddCreateDemMethod& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, DynamicWaveRoughness::value i)
  {
    return o << DynamicWaveRoughness::_xsd_DynamicWaveRoughness_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DynamicWaveRoughness& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ExecutionOptions& i)
  {
    if (i.outputMapFormat ())
    {
      o << ::std::endl << "outputMapFormat: " << *i.outputMapFormat ();
    }

    if (i.diagonal ())
    {
      o << ::std::endl << "diagonal: " << *i.diagonal ();
    }

    if (i.twoColumnTableAsMatrix ())
    {
      o << ::std::endl << "twoColumnTableAsMatrix: " << *i.twoColumnTableAsMatrix ();
    }

    if (i.keepEdgePits ())
    {
      o << ::std::endl << "keepEdgePits: " << *i.keepEdgePits ();
    }

    if (i.trueCellUnits ())
    {
      o << ::std::endl << "trueCellUnits: " << *i.trueCellUnits ();
    }

    if (i.cellCoordinate ())
    {
      o << ::std::endl << "cellCoordinate: " << *i.cellCoordinate ();
    }

    if (i.directionalValueUnit ())
    {
      o << ::std::endl << "directionalValueUnit: " << *i.directionalValueUnit ();
    }

    if (i.lddCreateDemMethod ())
    {
      o << ::std::endl << "lddCreateDemMethod: " << *i.lddCreateDemMethod ();
    }

    if (i.dynamicWaveRoughness ())
    {
      o << ::std::endl << "dynamicWaveRoughness: " << *i.dynamicWaveRoughness ();
    }

    if (i.runDirectory ())
    {
      o << ::std::endl << "runDirectory: " << *i.runDirectory ();
    }

    if (i.randomGeneratorSeed ())
    {
      o << ::std::endl << "randomGeneratorSeed: " << *i.randomGeneratorSeed ();
    }

    if (i.maskCompression ())
    {
      o << ::std::endl << "maskCompression: " << *i.maskCompression ();
    }

    if (i.useDiskStorage ())
    {
      o << ::std::endl << "useDiskStorage: " << *i.useDiskStorage ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Script& i)
  {
    if (i.executionOptions ())
    {
      o << ::std::endl << "executionOptions: " << *i.executionOptions ();
    }

    if (i.areaMap ())
    {
      o << ::std::endl << "areaMap: " << *i.areaMap ();
    }

    if (i.computationMask ())
    {
      o << ::std::endl << "computationMask: " << *i.computationMask ();
    }

    for (Script::definition_const_iterator
         b (i.definition ().begin ()), e (i.definition ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "definition: " << *b;
    }

    if (i.timer ())
    {
      o << ::std::endl << "timer: " << *i.timer ();
    }

    if (i.model ())
    {
      o << ::std::endl << "model: " << *i.model ();
    }

    for (Script::textStatistics_const_iterator
         b (i.textStatistics ().begin ()), e (i.textStatistics ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "textStatistics: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Model& i)
  {
    o << ::std::endl << "textModel: " << i.textModel ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TextStatisticsSubject& i)
  {
    o << ::std::endl << "fieldRef: " << i.fieldRef ();
    if (i.intervalRef ())
    {
      o << ::std::endl << "intervalRef: " << *i.intervalRef ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TextStatistics& i)
  {
    for (TextStatistics::textStatisticsSubject_const_iterator
         b (i.textStatisticsSubject ().begin ()), e (i.textStatisticsSubject ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "textStatisticsSubject: " << *b;
    }

    if (i.name ())
    {
      o << ::std::endl << "name: " << *i.name ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LookupRow& i)
  {
    for (LookupRow::lookupColumn_const_iterator
         b (i.lookupColumn ().begin ()), e (i.lookupColumn ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "lookupColumn: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Relation& i)
  {
    if (i.lookupTable ())
    {
      o << ::std::endl << "lookupTable: " << *i.lookupTable ();
    }

    if (i.indexedArray ())
    {
      o << ::std::endl << "indexedArray: " << *i.indexedArray ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, ArrayDimensionDataType::value i)
  {
    return o << ArrayDimensionDataType::_xsd_ArrayDimensionDataType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ArrayDimensionDataType& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, ArrayValueDataType::value i)
  {
    return o << ArrayValueDataType::_xsd_ArrayValueDataType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ArrayValueDataType& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IndexedArray& i)
  {
    o << ::std::endl << "dimensionDataType: " << i.dimensionDataType ();
    o << ::std::endl << "valueDataType: " << i.valueDataType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LookupTable& i)
  {
    for (LookupTable::lookupRow_const_iterator
         b (i.lookupRow ().begin ()), e (i.lookupRow ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "lookupRow: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FieldValueOrType& i)
  {
    if (i.dataType ())
    {
      o << ::std::endl << "dataType: " << *i.dataType ();
    }

    if (i.number ())
    {
      o << ::std::endl << "number: " << *i.number ();
    }

    if (i.spatialType ())
    {
      o << ::std::endl << "spatialType: " << *i.spatialType ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Definition& i)
  {
    if (i.description ())
    {
      o << ::std::endl << "description: " << *i.description ();
    }

    if (i.field ())
    {
      o << ::std::endl << "field: " << *i.field ();
    }

    if (i.relation ())
    {
      o << ::std::endl << "relation: " << *i.relation ();
    }

    if (i.modelExchange ())
    {
      o << ::std::endl << "modelExchange: " << *i.modelExchange ();
    }

    if (i.scriptInput ())
    {
      o << ::std::endl << "scriptInput: " << *i.scriptInput ();
    }

    if (i.scriptOutput ())
    {
      o << ::std::endl << "scriptOutput: " << *i.scriptOutput ();
    }

    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Boolean&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Nominal&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Ordinal&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Directional&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Ldd&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Scalar& i)
  {
    if (i.length ())
    {
      o << ::std::endl << "length: " << *i.length ();
    }

    if (i.mass ())
    {
      o << ::std::endl << "mass: " << *i.mass ();
    }

    if (i.time ())
    {
      o << ::std::endl << "time: " << *i.time ();
    }

    if (i.electricCurrent ())
    {
      o << ::std::endl << "electricCurrent: " << *i.electricCurrent ();
    }

    if (i.temperature ())
    {
      o << ::std::endl << "temperature: " << *i.temperature ();
    }

    if (i.amountOfSubstance ())
    {
      o << ::std::endl << "amountOfSubstance: " << *i.amountOfSubstance ();
    }

    if (i.luminousIntensity ())
    {
      o << ::std::endl << "luminousIntensity: " << *i.luminousIntensity ();
    }

    if (i.currency ())
    {
      o << ::std::endl << "currency: " << *i.currency ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DataType& i)
  {
    if (i.boolean ())
    {
      o << ::std::endl << "boolean: " << *i.boolean ();
    }

    if (i.nominal ())
    {
      o << ::std::endl << "nominal: " << *i.nominal ();
    }

    if (i.ordinal ())
    {
      o << ::std::endl << "ordinal: " << *i.ordinal ();
    }

    if (i.scalar ())
    {
      o << ::std::endl << "scalar: " << *i.scalar ();
    }

    if (i.directional ())
    {
      o << ::std::endl << "directional: " << *i.directional ();
    }

    if (i.ldd ())
    {
      o << ::std::endl << "ldd: " << *i.ldd ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DataTypeOfValue& i)
  {
    if (i.boolean ())
    {
      o << ::std::endl << "boolean: " << *i.boolean ();
    }

    if (i.ldd ())
    {
      o << ::std::endl << "ldd: " << *i.ldd ();
    }

    if (i.nominal ())
    {
      o << ::std::endl << "nominal: " << *i.nominal ();
    }

    if (i.ordinal ())
    {
      o << ::std::endl << "ordinal: " << *i.ordinal ();
    }

    if (i.scalar ())
    {
      o << ::std::endl << "scalar: " << *i.scalar ();
    }

    if (i.directional ())
    {
      o << ::std::endl << "directional: " << *i.directional ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CoordinateMask& i)
  {
    o << ::std::endl << "xMinimum: " << i.xMinimum ();
    o << ::std::endl << "xMaximum: " << i.xMaximum ();
    o << ::std::endl << "yMinimum: " << i.yMinimum ();
    o << ::std::endl << "yMaximum: " << i.yMaximum ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AreaMap& i)
  {
    o << ::std::endl << "nrRows: " << i.nrRows ();
    o << ::std::endl << "nrCols: " << i.nrCols ();
    if (i.cellSize ())
    {
      o << ::std::endl << "cellSize: " << *i.cellSize ();
    }

    if (i.xLowerLeftCorner ())
    {
      o << ::std::endl << "xLowerLeftCorner: " << *i.xLowerLeftCorner ();
    }

    if (i.yLowerLeftCorner ())
    {
      o << ::std::endl << "yLowerLeftCorner: " << *i.yLowerLeftCorner ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FieldReference& i)
  {
    o << ::std::endl << "ref: " << i.ref ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AreaMapScript& i)
  {
    if (i.fieldReference ())
    {
      o << ::std::endl << "fieldReference: " << *i.fieldReference ();
    }

    if (i.nrRows ())
    {
      o << ::std::endl << "nrRows: " << *i.nrRows ();
    }

    if (i.nrCols ())
    {
      o << ::std::endl << "nrCols: " << *i.nrCols ();
    }

    if (i.cellSize ())
    {
      o << ::std::endl << "cellSize: " << *i.cellSize ();
    }

    if (i.xLowerLeftCorner ())
    {
      o << ::std::endl << "xLowerLeftCorner: " << *i.xLowerLeftCorner ();
    }

    if (i.yLowerLeftCorner ())
    {
      o << ::std::endl << "yLowerLeftCorner: " << *i.yLowerLeftCorner ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, MaskMapType::value i)
  {
    return o << MaskMapType::_xsd_MaskMapType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MaskMapType& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ComputationMaskByAreaMap& i)
  {
    o << ::std::endl << "maskType: " << i.maskType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ComputationMask& i)
  {
    if (i.areaMap ())
    {
      o << ::std::endl << "areaMap: " << *i.areaMap ();
    }

    if (i.coordinates ())
    {
      o << ::std::endl << "coordinates: " << *i.coordinates ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimerOfModel& i)
  {
    o << ::std::endl << "integer: " << i.integer ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const IntegerTimer& i)
  {
    o << ::std::endl << "start: " << i.start ();
    if (i.end ())
    {
      o << ::std::endl << "end: " << *i.end ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimerContext& i)
  {
    o << ::std::endl << "current: " << i.current ();
    if (i.start ())
    {
      o << ::std::endl << "start: " << *i.start ();
    }

    if (i.end ())
    {
      o << ::std::endl << "end: " << *i.end ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CheckContext& i)
  {
    if (i.areaMap ())
    {
      o << ::std::endl << "areaMap: " << *i.areaMap ();
    }

    if (i.computationMask ())
    {
      o << ::std::endl << "computationMask: " << *i.computationMask ();
    }

    if (i.timer ())
    {
      o << ::std::endl << "timer: " << *i.timer ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RunContext& i)
  {
    o << ::std::endl << "areaMap: " << i.areaMap ();
    if (i.computationMask ())
    {
      o << ::std::endl << "computationMask: " << *i.computationMask ();
    }

    o << ::std::endl << "timer: " << i.timer ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInLibraryManifest& i)
  {
    for (LinkInLibraryManifest::function_const_iterator
         b (i.function ().begin ()), e (i.function ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "function: " << *b;
    }

    for (LinkInLibraryManifest::class_const_iterator
         b (i.class_ ().begin ()), e (i.class_ ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "class: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInClassManifest& i)
  {
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "constructor: " << i.constructor ();
    for (LinkInClassManifest::method_const_iterator
         b (i.method ().begin ()), e (i.method ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "method: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInClassConstructor& i)
  {
    if (i.stringArgument ())
    {
      o << ::std::endl << "stringArgument: " << *i.stringArgument ();
    }

    for (LinkInClassConstructor::argument_const_iterator
         b (i.argument ().begin ()), e (i.argument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FieldType& i)
  {
    o << ::std::endl << "dataType: " << i.dataType ();
    o << ::std::endl << "spatialType: " << i.spatialType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const FieldTypeOfValue& i)
  {
    o << ::std::endl << "dataType: " << i.dataType ();
    o << ::std::endl << "spatialType: " << i.spatialType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInClassMethod& i)
  {
    o << ::std::endl << "name: " << i.name ();
    for (LinkInClassMethod::result_const_iterator
         b (i.result ().begin ()), e (i.result ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "result: " << *b;
    }

    if (i.stringArgument ())
    {
      o << ::std::endl << "stringArgument: " << *i.stringArgument ();
    }

    for (LinkInClassMethod::argument_const_iterator
         b (i.argument ().begin ()), e (i.argument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInFunctionManifest& i)
  {
    o << ::std::endl << "name: " << i.name ();
    for (LinkInFunctionManifest::result_const_iterator
         b (i.result ().begin ()), e (i.result ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "result: " << *b;
    }

    if (i.stringArgument ())
    {
      o << ::std::endl << "stringArgument: " << *i.stringArgument ();
    }

    for (LinkInFunctionManifest::argument_const_iterator
         b (i.argument ().begin ()), e (i.argument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CallPoint& i)
  {
    if (i.object ())
    {
      o << ::std::endl << "object: " << *i.object ();
    }

    if (i.function ())
    {
      o << ::std::endl << "function: " << *i.function ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInCheckInput& i)
  {
    o << ::std::endl << "context: " << i.context ();
    o << ::std::endl << "callPoint: " << i.callPoint ();
    for (LinkInCheckInput::result_const_iterator
         b (i.result ().begin ()), e (i.result ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "result: " << *b;
    }

    if (i.stringArgument ())
    {
      o << ::std::endl << "stringArgument: " << *i.stringArgument ();
    }

    for (LinkInCheckInput::argument_const_iterator
         b (i.argument ().begin ()), e (i.argument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInCheckResult& i)
  {
    if (i.error ())
    {
      o << ::std::endl << "error: " << *i.error ();
    }

    for (LinkInCheckResult::result_const_iterator
         b (i.result ().begin ()), e (i.result ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "result: " << *b;
    }

    for (LinkInCheckResult::argument_const_iterator
         b (i.argument ().begin ()), e (i.argument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInExecuteInput& i)
  {
    o << ::std::endl << "context: " << i.context ();
    o << ::std::endl << "callPoint: " << i.callPoint ();
    for (LinkInExecuteInput::result_const_iterator
         b (i.result ().begin ()), e (i.result ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "result: " << *b;
    }

    if (i.stringArgument ())
    {
      o << ::std::endl << "stringArgument: " << *i.stringArgument ();
    }

    for (LinkInExecuteInput::argument_const_iterator
         b (i.argument ().begin ()), e (i.argument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LinkInExecuteResult& i)
  {
    if (i.error ())
    {
      o << ::std::endl << "error: " << *i.error ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const object& i)
  {
    o << ::std::endl << "className: " << i.className ();
    o << ::std::endl << "objectName: " << i.objectName ();
    if (i.constructor ())
    {
      o << ::std::endl << "constructor: " << *i.constructor ();
    }

    if (i.methodName ())
    {
      o << ::std::endl << "methodName: " << *i.methodName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const function& i)
  {
    o << ::std::endl << "name: " << i.name ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace pcrxml
{
  ::std::unique_ptr< ::pcrxml::Script >
  script (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::Script > (
      ::pcrxml::script (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Script > (
      ::pcrxml::script (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Script > (
      ::pcrxml::script (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::script (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::script (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::script (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::script (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::script (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::script (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::Script > (
      ::pcrxml::script (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Script > (
      ::pcrxml::script (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Script > (
      ::pcrxml::script (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::Script > (
        ::pcrxml::script (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "script" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::Script > r (
        ::xsd::cxx::tree::traits< ::pcrxml::Script, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "script",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::Script >
  script (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "script" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::Script > r (
        ::xsd::cxx::tree::traits< ::pcrxml::Script, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "script",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
      ::pcrxml::linkInLibraryManifest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
      ::pcrxml::linkInLibraryManifest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
      ::pcrxml::linkInLibraryManifest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInLibraryManifest (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInLibraryManifest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInLibraryManifest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInLibraryManifest (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInLibraryManifest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInLibraryManifest (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
      ::pcrxml::linkInLibraryManifest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
      ::pcrxml::linkInLibraryManifest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
      ::pcrxml::linkInLibraryManifest (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > (
        ::pcrxml::linkInLibraryManifest (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInLibraryManifest" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInLibraryManifest, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInLibraryManifest",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest >
  linkInLibraryManifest (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "linkInLibraryManifest" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInLibraryManifest > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInLibraryManifest, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInLibraryManifest",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
      ::pcrxml::linkInCheckInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
      ::pcrxml::linkInCheckInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
      ::pcrxml::linkInCheckInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInCheckInput (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInCheckInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInCheckInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInCheckInput (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInCheckInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInCheckInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
      ::pcrxml::linkInCheckInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
      ::pcrxml::linkInCheckInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
      ::pcrxml::linkInCheckInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::LinkInCheckInput > (
        ::pcrxml::linkInCheckInput (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInCheckInput" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInCheckInput > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInCheckInput, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInCheckInput",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckInput >
  linkInCheckInput (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "linkInCheckInput" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInCheckInput > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInCheckInput, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInCheckInput",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
      ::pcrxml::linkInCheckResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
      ::pcrxml::linkInCheckResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
      ::pcrxml::linkInCheckResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInCheckResult (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInCheckResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInCheckResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInCheckResult (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInCheckResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInCheckResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
      ::pcrxml::linkInCheckResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
      ::pcrxml::linkInCheckResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
      ::pcrxml::linkInCheckResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::LinkInCheckResult > (
        ::pcrxml::linkInCheckResult (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInCheckResult" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInCheckResult > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInCheckResult, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInCheckResult",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInCheckResult >
  linkInCheckResult (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "linkInCheckResult" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInCheckResult > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInCheckResult, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInCheckResult",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
      ::pcrxml::linkInExecuteInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
      ::pcrxml::linkInExecuteInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
      ::pcrxml::linkInExecuteInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInExecuteInput (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInExecuteInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInExecuteInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInExecuteInput (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInExecuteInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInExecuteInput (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
      ::pcrxml::linkInExecuteInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
      ::pcrxml::linkInExecuteInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
      ::pcrxml::linkInExecuteInput (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > (
        ::pcrxml::linkInExecuteInput (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInExecuteInput" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInExecuteInput, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInExecuteInput",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteInput >
  linkInExecuteInput (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "linkInExecuteInput" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInExecuteInput > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInExecuteInput, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInExecuteInput",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
      ::pcrxml::linkInExecuteResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
      ::pcrxml::linkInExecuteResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
      ::pcrxml::linkInExecuteResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInExecuteResult (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInExecuteResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::linkInExecuteResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInExecuteResult (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInExecuteResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::linkInExecuteResult (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
      ::pcrxml::linkInExecuteResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
      ::pcrxml::linkInExecuteResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
      ::pcrxml::linkInExecuteResult (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > (
        ::pcrxml::linkInExecuteResult (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInExecuteResult" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInExecuteResult, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInExecuteResult",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::LinkInExecuteResult >
  linkInExecuteResult (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "linkInExecuteResult" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::LinkInExecuteResult > r (
        ::xsd::cxx::tree::traits< ::pcrxml::LinkInExecuteResult, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "linkInExecuteResult",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::AreaMap > (
      ::pcrxml::areaMap (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::AreaMap > (
      ::pcrxml::areaMap (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::AreaMap > (
      ::pcrxml::areaMap (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::areaMap (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::areaMap (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::areaMap (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::areaMap (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::areaMap (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::areaMap (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::AreaMap > (
      ::pcrxml::areaMap (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::AreaMap > (
      ::pcrxml::areaMap (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::AreaMap > (
      ::pcrxml::areaMap (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::AreaMap > (
        ::pcrxml::areaMap (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "areaMap" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::AreaMap > r (
        ::xsd::cxx::tree::traits< ::pcrxml::AreaMap, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "areaMap",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::AreaMap >
  areaMap (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "areaMap" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::AreaMap > r (
        ::xsd::cxx::tree::traits< ::pcrxml::AreaMap, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "areaMap",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::Definition > (
      ::pcrxml::definition (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Definition > (
      ::pcrxml::definition (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Definition > (
      ::pcrxml::definition (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::definition (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::definition (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::definition (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::definition (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::definition (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::definition (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::Definition > (
      ::pcrxml::definition (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Definition > (
      ::pcrxml::definition (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Definition > (
      ::pcrxml::definition (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::Definition > (
        ::pcrxml::definition (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "definition" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::Definition > r (
        ::xsd::cxx::tree::traits< ::pcrxml::Definition, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "definition",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::Definition >
  definition (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "definition" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::Definition > r (
        ::xsd::cxx::tree::traits< ::pcrxml::Definition, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "definition",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::Model > (
      ::pcrxml::model (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Model > (
      ::pcrxml::model (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Model > (
      ::pcrxml::model (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::model (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::model (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::model (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::model (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::model (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::model (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::Model > (
      ::pcrxml::model (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Model > (
      ::pcrxml::model (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::Model > (
      ::pcrxml::model (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::Model > (
        ::pcrxml::model (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "model" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::Model > r (
        ::xsd::cxx::tree::traits< ::pcrxml::Model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "model",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::Model >
  model (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "model" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::Model > r (
        ::xsd::cxx::tree::traits< ::pcrxml::Model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "model",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::TextStatistics > (
      ::pcrxml::textStatistics (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::TextStatistics > (
      ::pcrxml::textStatistics (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::TextStatistics > (
      ::pcrxml::textStatistics (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::textStatistics (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::textStatistics (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::pcrxml::textStatistics (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::textStatistics (isrc, f, p);
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::textStatistics (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::pcrxml::textStatistics (isrc, h, f, p);
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::pcrxml::TextStatistics > (
      ::pcrxml::textStatistics (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::TextStatistics > (
      ::pcrxml::textStatistics (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::pcrxml::TextStatistics > (
      ::pcrxml::textStatistics (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::pcrxml::TextStatistics > (
        ::pcrxml::textStatistics (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "textStatistics" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::TextStatistics > r (
        ::xsd::cxx::tree::traits< ::pcrxml::TextStatistics, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "textStatistics",
      "http://www.pcraster.nl/pcrxml");
  }

  ::std::unique_ptr< ::pcrxml::TextStatistics >
  textStatistics (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "textStatistics" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      ::std::unique_ptr< ::pcrxml::TextStatistics > r (
        ::xsd::cxx::tree::traits< ::pcrxml::TextStatistics, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "textStatistics",
      "http://www.pcraster.nl/pcrxml");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace pcrxml
{
  void
  script (::std::ostream& o,
          const ::pcrxml::Script& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::script (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  script (::std::ostream& o,
          const ::pcrxml::Script& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::script (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  script (::std::ostream& o,
          const ::pcrxml::Script& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::script (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  script (::xercesc::XMLFormatTarget& t,
          const ::pcrxml::Script& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::script (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  script (::xercesc::XMLFormatTarget& t,
          const ::pcrxml::Script& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::script (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  script (::xercesc::XMLFormatTarget& t,
          const ::pcrxml::Script& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::script (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  script (::xercesc::DOMDocument& d,
          const ::pcrxml::Script& s,
          ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "script" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "script",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  script (const ::pcrxml::Script& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "script",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::script (*d, s, f);
    return d;
  }

  void
  linkInLibraryManifest (::std::ostream& o,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInLibraryManifest (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInLibraryManifest (::std::ostream& o,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         ::xml_schema::error_handler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInLibraryManifest (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInLibraryManifest (::std::ostream& o,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInLibraryManifest (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInLibraryManifest (::xercesc::XMLFormatTarget& t,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInLibraryManifest (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInLibraryManifest (::xercesc::XMLFormatTarget& t,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         ::xml_schema::error_handler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInLibraryManifest (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInLibraryManifest (::xercesc::XMLFormatTarget& t,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::string& e,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInLibraryManifest (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInLibraryManifest (::xercesc::DOMDocument& d,
                         const ::pcrxml::LinkInLibraryManifest& s,
                         ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInLibraryManifest" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "linkInLibraryManifest",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  linkInLibraryManifest (const ::pcrxml::LinkInLibraryManifest& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "linkInLibraryManifest",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::linkInLibraryManifest (*d, s, f);
    return d;
  }

  void
  linkInCheckInput (::std::ostream& o,
                    const ::pcrxml::LinkInCheckInput& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckInput (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInCheckInput (::std::ostream& o,
                    const ::pcrxml::LinkInCheckInput& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckInput (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckInput (::std::ostream& o,
                    const ::pcrxml::LinkInCheckInput& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckInput (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckInput (::xercesc::XMLFormatTarget& t,
                    const ::pcrxml::LinkInCheckInput& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckInput (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInCheckInput (::xercesc::XMLFormatTarget& t,
                    const ::pcrxml::LinkInCheckInput& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckInput (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckInput (::xercesc::XMLFormatTarget& t,
                    const ::pcrxml::LinkInCheckInput& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckInput (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckInput (::xercesc::DOMDocument& d,
                    const ::pcrxml::LinkInCheckInput& s,
                    ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInCheckInput" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "linkInCheckInput",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  linkInCheckInput (const ::pcrxml::LinkInCheckInput& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "linkInCheckInput",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::linkInCheckInput (*d, s, f);
    return d;
  }

  void
  linkInCheckResult (::std::ostream& o,
                     const ::pcrxml::LinkInCheckResult& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckResult (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInCheckResult (::std::ostream& o,
                     const ::pcrxml::LinkInCheckResult& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckResult (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckResult (::std::ostream& o,
                     const ::pcrxml::LinkInCheckResult& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckResult (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckResult (::xercesc::XMLFormatTarget& t,
                     const ::pcrxml::LinkInCheckResult& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckResult (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInCheckResult (::xercesc::XMLFormatTarget& t,
                     const ::pcrxml::LinkInCheckResult& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckResult (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckResult (::xercesc::XMLFormatTarget& t,
                     const ::pcrxml::LinkInCheckResult& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInCheckResult (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInCheckResult (::xercesc::DOMDocument& d,
                     const ::pcrxml::LinkInCheckResult& s,
                     ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInCheckResult" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "linkInCheckResult",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  linkInCheckResult (const ::pcrxml::LinkInCheckResult& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "linkInCheckResult",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::linkInCheckResult (*d, s, f);
    return d;
  }

  void
  linkInExecuteInput (::std::ostream& o,
                      const ::pcrxml::LinkInExecuteInput& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteInput (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInExecuteInput (::std::ostream& o,
                      const ::pcrxml::LinkInExecuteInput& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteInput (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteInput (::std::ostream& o,
                      const ::pcrxml::LinkInExecuteInput& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteInput (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteInput (::xercesc::XMLFormatTarget& t,
                      const ::pcrxml::LinkInExecuteInput& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteInput (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInExecuteInput (::xercesc::XMLFormatTarget& t,
                      const ::pcrxml::LinkInExecuteInput& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteInput (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteInput (::xercesc::XMLFormatTarget& t,
                      const ::pcrxml::LinkInExecuteInput& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteInput (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteInput (::xercesc::DOMDocument& d,
                      const ::pcrxml::LinkInExecuteInput& s,
                      ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInExecuteInput" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "linkInExecuteInput",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  linkInExecuteInput (const ::pcrxml::LinkInExecuteInput& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "linkInExecuteInput",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::linkInExecuteInput (*d, s, f);
    return d;
  }

  void
  linkInExecuteResult (::std::ostream& o,
                       const ::pcrxml::LinkInExecuteResult& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteResult (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInExecuteResult (::std::ostream& o,
                       const ::pcrxml::LinkInExecuteResult& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteResult (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteResult (::std::ostream& o,
                       const ::pcrxml::LinkInExecuteResult& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteResult (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteResult (::xercesc::XMLFormatTarget& t,
                       const ::pcrxml::LinkInExecuteResult& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteResult (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  linkInExecuteResult (::xercesc::XMLFormatTarget& t,
                       const ::pcrxml::LinkInExecuteResult& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteResult (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteResult (::xercesc::XMLFormatTarget& t,
                       const ::pcrxml::LinkInExecuteResult& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::linkInExecuteResult (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  linkInExecuteResult (::xercesc::DOMDocument& d,
                       const ::pcrxml::LinkInExecuteResult& s,
                       ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "linkInExecuteResult" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "linkInExecuteResult",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  linkInExecuteResult (const ::pcrxml::LinkInExecuteResult& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "linkInExecuteResult",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::linkInExecuteResult (*d, s, f);
    return d;
  }

  void
  areaMap (::std::ostream& o,
           const ::pcrxml::AreaMap& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::areaMap (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  areaMap (::std::ostream& o,
           const ::pcrxml::AreaMap& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::areaMap (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  areaMap (::std::ostream& o,
           const ::pcrxml::AreaMap& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::areaMap (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  areaMap (::xercesc::XMLFormatTarget& t,
           const ::pcrxml::AreaMap& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::areaMap (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  areaMap (::xercesc::XMLFormatTarget& t,
           const ::pcrxml::AreaMap& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::areaMap (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  areaMap (::xercesc::XMLFormatTarget& t,
           const ::pcrxml::AreaMap& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::areaMap (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  areaMap (::xercesc::DOMDocument& d,
           const ::pcrxml::AreaMap& s,
           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "areaMap" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "areaMap",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  areaMap (const ::pcrxml::AreaMap& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "areaMap",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::areaMap (*d, s, f);
    return d;
  }

  void
  definition (::std::ostream& o,
              const ::pcrxml::Definition& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::definition (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  definition (::std::ostream& o,
              const ::pcrxml::Definition& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::definition (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  definition (::std::ostream& o,
              const ::pcrxml::Definition& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::definition (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  definition (::xercesc::XMLFormatTarget& t,
              const ::pcrxml::Definition& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::definition (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  definition (::xercesc::XMLFormatTarget& t,
              const ::pcrxml::Definition& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::definition (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  definition (::xercesc::XMLFormatTarget& t,
              const ::pcrxml::Definition& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::definition (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  definition (::xercesc::DOMDocument& d,
              const ::pcrxml::Definition& s,
              ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "definition" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "definition",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  definition (const ::pcrxml::Definition& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "definition",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::definition (*d, s, f);
    return d;
  }

  void
  model (::std::ostream& o,
         const ::pcrxml::Model& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::model (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  model (::std::ostream& o,
         const ::pcrxml::Model& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::model (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model (::std::ostream& o,
         const ::pcrxml::Model& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::model (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model (::xercesc::XMLFormatTarget& t,
         const ::pcrxml::Model& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::model (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  model (::xercesc::XMLFormatTarget& t,
         const ::pcrxml::Model& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::model (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model (::xercesc::XMLFormatTarget& t,
         const ::pcrxml::Model& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::model (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model (::xercesc::DOMDocument& d,
         const ::pcrxml::Model& s,
         ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "model" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "model",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  model (const ::pcrxml::Model& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "model",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::model (*d, s, f);
    return d;
  }

  void
  textStatistics (::std::ostream& o,
                  const ::pcrxml::TextStatistics& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::textStatistics (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  textStatistics (::std::ostream& o,
                  const ::pcrxml::TextStatistics& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::textStatistics (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  textStatistics (::std::ostream& o,
                  const ::pcrxml::TextStatistics& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::textStatistics (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  textStatistics (::xercesc::XMLFormatTarget& t,
                  const ::pcrxml::TextStatistics& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::textStatistics (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  textStatistics (::xercesc::XMLFormatTarget& t,
                  const ::pcrxml::TextStatistics& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::textStatistics (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  textStatistics (::xercesc::XMLFormatTarget& t,
                  const ::pcrxml::TextStatistics& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::pcrxml::textStatistics (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  textStatistics (::xercesc::DOMDocument& d,
                  const ::pcrxml::TextStatistics& s,
                  ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "textStatistics" &&
        n.namespace_ () == "http://www.pcraster.nl/pcrxml")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "textStatistics",
        "http://www.pcraster.nl/pcrxml");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  textStatistics (const ::pcrxml::TextStatistics& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "textStatistics",
        "http://www.pcraster.nl/pcrxml",
        m, f));

    ::pcrxml::textStatistics (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpatialType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SpatialType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const SpatialType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpatialTypeOfValue& i)
  {
    e << static_cast< const ::pcrxml::SpatialType& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SpatialTypeOfValue& i)
  {
    a << static_cast< const ::pcrxml::SpatialType& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const SpatialTypeOfValue& i)
  {
    l << static_cast< const ::pcrxml::SpatialType& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MemoryExchange& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MemoryExchange& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const MemoryExchange& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Exchange& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // external
    //
    if (i.external ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "external",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.external ();
    }

    // memoryExchange
    //
    if (i.memoryExchange ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "memoryExchange",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.memoryExchange ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Description& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // text
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "text",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.text ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ModelInputType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ModelInputType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ModelInputType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ModelOutputType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ModelOutputType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ModelOutputType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ModelExchange& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // input
    //
    if (i.input ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "input",
          e));

      a << *i.input ();
    }

    // output
    //
    if (i.output ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "output",
          e));

      a << *i.output ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LookupColumn& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LookupColumn& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const LookupColumn& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputMapFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // pcrasterMapFormat
    //
    if (i.pcrasterMapFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pcrasterMapFormat",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.pcrasterMapFormat ();
    }

    // bandMapFormat
    //
    if (i.bandMapFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bandMapFormat",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.bandMapFormat ();
    }

    // esriGridFormat
    //
    if (i.esriGridFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "esriGridFormat",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.esriGridFormat ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CellCoordinate& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CellCoordinate& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const CellCoordinate& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DirectionalValueUnit& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DirectionalValueUnit& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DirectionalValueUnit& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const LddCreateDemMethod& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LddCreateDemMethod& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const LddCreateDemMethod& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DynamicWaveRoughness& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DynamicWaveRoughness& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DynamicWaveRoughness& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExecutionOptions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // outputMapFormat
    //
    if (i.outputMapFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "outputMapFormat",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.outputMapFormat ();
    }

    // diagonal
    //
    if (i.diagonal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "diagonal",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.diagonal ();
    }

    // twoColumnTableAsMatrix
    //
    if (i.twoColumnTableAsMatrix ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "twoColumnTableAsMatrix",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.twoColumnTableAsMatrix ();
    }

    // keepEdgePits
    //
    if (i.keepEdgePits ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "keepEdgePits",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.keepEdgePits ();
    }

    // trueCellUnits
    //
    if (i.trueCellUnits ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trueCellUnits",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.trueCellUnits ();
    }

    // cellCoordinate
    //
    if (i.cellCoordinate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cellCoordinate",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.cellCoordinate ();
    }

    // directionalValueUnit
    //
    if (i.directionalValueUnit ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "directionalValueUnit",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.directionalValueUnit ();
    }

    // lddCreateDemMethod
    //
    if (i.lddCreateDemMethod ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lddCreateDemMethod",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.lddCreateDemMethod ();
    }

    // dynamicWaveRoughness
    //
    if (i.dynamicWaveRoughness ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dynamicWaveRoughness",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.dynamicWaveRoughness ();
    }

    // runDirectory
    //
    if (i.runDirectory ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "runDirectory",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.runDirectory ();
    }

    // randomGeneratorSeed
    //
    if (i.randomGeneratorSeed ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "randomGeneratorSeed",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.randomGeneratorSeed ();
    }

    // maskCompression
    //
    if (i.maskCompression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maskCompression",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.maskCompression ();
    }

    // useDiskStorage
    //
    if (i.useDiskStorage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "useDiskStorage",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.useDiskStorage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Script& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // executionOptions
    //
    if (i.executionOptions ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "executionOptions",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.executionOptions ();
    }

    // areaMap
    //
    if (i.areaMap ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "areaMap",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.areaMap ();
    }

    // computationMask
    //
    if (i.computationMask ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "computationMask",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.computationMask ();
    }

    // definition
    //
    for (Script::definition_const_iterator
         b (i.definition ().begin ()), n (i.definition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "definition",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // timer
    //
    if (i.timer ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timer",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.timer ();
    }

    // model
    //
    if (i.model ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "model",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.model ();
    }

    // textStatistics
    //
    for (Script::textStatistics_const_iterator
         b (i.textStatistics ().begin ()), n (i.textStatistics ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "textStatistics",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Model& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // textModel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "textModel",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.textModel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TextStatisticsSubject& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // fieldRef
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fieldRef",
          e));

      a << i.fieldRef ();
    }

    // intervalRef
    //
    if (i.intervalRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "intervalRef",
          e));

      a << *i.intervalRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TextStatistics& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // textStatisticsSubject
    //
    for (TextStatistics::textStatisticsSubject_const_iterator
         b (i.textStatisticsSubject ().begin ()), n (i.textStatisticsSubject ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "textStatisticsSubject",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LookupRow& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // lookupColumn
    //
    for (LookupRow::lookupColumn_const_iterator
         b (i.lookupColumn ().begin ()), n (i.lookupColumn ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookupColumn",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Relation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // lookupTable
    //
    if (i.lookupTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookupTable",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.lookupTable ();
    }

    // indexedArray
    //
    if (i.indexedArray ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "indexedArray",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.indexedArray ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ArrayDimensionDataType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ArrayDimensionDataType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ArrayDimensionDataType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ArrayValueDataType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ArrayValueDataType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ArrayValueDataType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const IndexedArray& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dimensionDataType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dimensionDataType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.dimensionDataType ();
    }

    // valueDataType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueDataType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.valueDataType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LookupTable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // lookupRow
    //
    for (LookupTable::lookupRow_const_iterator
         b (i.lookupRow ().begin ()), n (i.lookupRow ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookupRow",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FieldValueOrType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    if (i.dataType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.dataType ();
    }

    // number
    //
    if (i.number ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "number",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.number ());
    }

    // spatialType
    //
    if (i.spatialType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spatialType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.spatialType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Definition& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.description ();
    }

    // field
    //
    if (i.field ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.field ();
    }

    // relation
    //
    if (i.relation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relation",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.relation ();
    }

    // modelExchange
    //
    if (i.modelExchange ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modelExchange",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.modelExchange ();
    }

    // scriptInput
    //
    if (i.scriptInput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scriptInput",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.scriptInput ();
    }

    // scriptOutput
    //
    if (i.scriptOutput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scriptOutput",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.scriptOutput ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Boolean& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Boolean&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Boolean&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Nominal& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Nominal&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Nominal&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Ordinal& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Ordinal&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Ordinal&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Directional& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Directional&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Directional&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Ldd& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Ldd&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Ldd&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Scalar& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // length
    //
    if (i.length ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "length",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.length ());
    }

    // mass
    //
    if (i.mass ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mass",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.mass ());
    }

    // time
    //
    if (i.time ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "time",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.time ());
    }

    // electricCurrent
    //
    if (i.electricCurrent ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "electricCurrent",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.electricCurrent ());
    }

    // temperature
    //
    if (i.temperature ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "temperature",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.temperature ());
    }

    // amountOfSubstance
    //
    if (i.amountOfSubstance ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "amountOfSubstance",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.amountOfSubstance ());
    }

    // luminousIntensity
    //
    if (i.luminousIntensity ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "luminousIntensity",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.luminousIntensity ());
    }

    // currency
    //
    if (i.currency ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "currency",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.currency ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean
    //
    if (i.boolean ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boolean",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.boolean ();
    }

    // nominal
    //
    if (i.nominal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nominal",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.nominal ();
    }

    // ordinal
    //
    if (i.ordinal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ordinal",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.ordinal ();
    }

    // scalar
    //
    if (i.scalar ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scalar",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.scalar ();
    }

    // directional
    //
    if (i.directional ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "directional",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.directional ();
    }

    // ldd
    //
    if (i.ldd ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ldd",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.ldd ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataTypeOfValue& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean
    //
    if (i.boolean ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boolean",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.boolean ();
    }

    // ldd
    //
    if (i.ldd ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ldd",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.ldd ();
    }

    // nominal
    //
    if (i.nominal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nominal",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.nominal ();
    }

    // ordinal
    //
    if (i.ordinal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ordinal",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.ordinal ();
    }

    // scalar
    //
    if (i.scalar ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scalar",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.scalar ();
    }

    // directional
    //
    if (i.directional ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "directional",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.directional ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CoordinateMask& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // xMinimum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xMinimum",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(i.xMinimum ());
    }

    // xMaximum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xMaximum",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(i.xMaximum ());
    }

    // yMinimum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMinimum",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(i.yMinimum ());
    }

    // yMaximum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMaximum",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(i.yMaximum ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AreaMap& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // nrRows
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nrRows",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.nrRows ();
    }

    // nrCols
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nrCols",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.nrCols ();
    }

    // cellSize
    //
    if (i.cellSize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cellSize",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.cellSize ());
    }

    // xLowerLeftCorner
    //
    if (i.xLowerLeftCorner ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xLowerLeftCorner",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.xLowerLeftCorner ());
    }

    // yLowerLeftCorner
    //
    if (i.yLowerLeftCorner ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yLowerLeftCorner",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.yLowerLeftCorner ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FieldReference& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AreaMapScript& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // fieldReference
    //
    if (i.fieldReference ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fieldReference",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.fieldReference ();
    }

    // nrRows
    //
    if (i.nrRows ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nrRows",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.nrRows ();
    }

    // nrCols
    //
    if (i.nrCols ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nrCols",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.nrCols ();
    }

    // cellSize
    //
    if (i.cellSize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cellSize",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.cellSize ());
    }

    // xLowerLeftCorner
    //
    if (i.xLowerLeftCorner ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xLowerLeftCorner",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.xLowerLeftCorner ());
    }

    // yLowerLeftCorner
    //
    if (i.yLowerLeftCorner ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yLowerLeftCorner",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << ::xml_schema::as_double(*i.yLowerLeftCorner ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MaskMapType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MaskMapType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const MaskMapType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComputationMaskByAreaMap& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // maskType
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maskType",
          e));

      a << i.maskType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComputationMask& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // areaMap
    //
    if (i.areaMap ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "areaMap",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.areaMap ();
    }

    // coordinates
    //
    if (i.coordinates ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coordinates",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.coordinates ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimerOfModel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "integer",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.integer ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IntegerTimer& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // start
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "start",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.start ();
    }

    // end
    //
    if (i.end ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "end",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.end ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimerContext& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // current
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "current",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.current ();
    }

    // start
    //
    if (i.start ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "start",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.start ();
    }

    // end
    //
    if (i.end ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "end",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.end ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CheckContext& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // areaMap
    //
    if (i.areaMap ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "areaMap",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.areaMap ();
    }

    // computationMask
    //
    if (i.computationMask ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "computationMask",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.computationMask ();
    }

    // timer
    //
    if (i.timer ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timer",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.timer ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RunContext& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // areaMap
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "areaMap",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.areaMap ();
    }

    // computationMask
    //
    if (i.computationMask ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "computationMask",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.computationMask ();
    }

    // timer
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timer",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.timer ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInLibraryManifest& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // function
    //
    for (LinkInLibraryManifest::function_const_iterator
         b (i.function ().begin ()), n (i.function ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "function",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // class
    //
    for (LinkInLibraryManifest::class_const_iterator
         b (i.class_ ().begin ()), n (i.class_ ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInClassManifest& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.name ();
    }

    // constructor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constructor",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.constructor ();
    }

    // method
    //
    for (LinkInClassManifest::method_const_iterator
         b (i.method ().begin ()), n (i.method ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInClassConstructor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // stringArgument
    //
    if (i.stringArgument ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stringArgument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.stringArgument ();
    }

    // argument
    //
    for (LinkInClassConstructor::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FieldType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.dataType ();
    }

    // spatialType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spatialType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.spatialType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FieldTypeOfValue& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.dataType ();
    }

    // spatialType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spatialType",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.spatialType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInClassMethod& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.name ();
    }

    // result
    //
    for (LinkInClassMethod::result_const_iterator
         b (i.result ().begin ()), n (i.result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // stringArgument
    //
    if (i.stringArgument ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stringArgument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.stringArgument ();
    }

    // argument
    //
    for (LinkInClassMethod::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInFunctionManifest& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.name ();
    }

    // result
    //
    for (LinkInFunctionManifest::result_const_iterator
         b (i.result ().begin ()), n (i.result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // stringArgument
    //
    if (i.stringArgument ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stringArgument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.stringArgument ();
    }

    // argument
    //
    for (LinkInFunctionManifest::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CallPoint& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // object
    //
    if (i.object ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "object",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.object ();
    }

    // function
    //
    if (i.function ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "function",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.function ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInCheckInput& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // context
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "context",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.context ();
    }

    // callPoint
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "callPoint",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.callPoint ();
    }

    // result
    //
    for (LinkInCheckInput::result_const_iterator
         b (i.result ().begin ()), n (i.result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // stringArgument
    //
    if (i.stringArgument ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stringArgument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.stringArgument ();
    }

    // argument
    //
    for (LinkInCheckInput::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInCheckResult& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // error
    //
    if (i.error ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.error ();
    }

    // result
    //
    for (LinkInCheckResult::result_const_iterator
         b (i.result ().begin ()), n (i.result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // argument
    //
    for (LinkInCheckResult::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInExecuteInput& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // context
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "context",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.context ();
    }

    // callPoint
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "callPoint",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.callPoint ();
    }

    // result
    //
    for (LinkInExecuteInput::result_const_iterator
         b (i.result ().begin ()), n (i.result ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }

    // stringArgument
    //
    if (i.stringArgument ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stringArgument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.stringArgument ();
    }

    // argument
    //
    for (LinkInExecuteInput::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkInExecuteResult& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // error
    //
    if (i.error ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.error ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const object& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // className
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "className",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.className ();
    }

    // objectName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "objectName",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.objectName ();
    }

    // constructor
    //
    if (i.constructor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constructor",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.constructor ();
    }

    // methodName
    //
    if (i.methodName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "methodName",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << *i.methodName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const function& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.pcraster.nl/pcrxml",
          e));

      s << i.name ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

